"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.symbol");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.object.get-own-property-descriptors");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("core-js/modules/web.dom-collections.for-each");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

require("regenerator-runtime/runtime");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _private_utils = require("../private_utils");

var _abstract_model = _interopRequireDefault(require("./abstract_model"));

var _table_or_view_query_result = _interopRequireDefault(require("./table_or_view_query_result"));

var _view_metadata_query_result = _interopRequireDefault(require("./view_metadata_query_result"));

var RecordColoring = _interopRequireWildcard(require("./record_coloring"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// This doesn't follow our enum naming conventions because we want the keys
// to mirror the method/getter names on the model class.
var WatchableViewKeys = Object.freeze({
  name: 'name'
});
/**
 * A key in {@link View} that can be watched.
 * - `name`
 */

/**
 * A class that represents an Airtable view. Every {@link Table} has one or more views.
 *
 * @docsPath models/View
 */
var View =
/*#__PURE__*/
function (_AbstractModel) {
  (0, _inherits2.default)(View, _AbstractModel);
  (0, _createClass2.default)(View, null, [{
    key: "_isWatchableKey",

    /** @internal */

    /** @internal */
    value: function _isWatchableKey(key) {
      return (0, _private_utils.isEnumValue)(WatchableViewKeys, key);
    }
    /** @internal */

  }]);

  /**
   * @internal
   */
  function View(baseData, parentTable, viewDataStore, viewId) {
    var _this;

    (0, _classCallCheck2.default)(this, View);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(View).call(this, baseData, viewId));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_parentTable", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_viewDataStore", void 0);
    _this._parentTable = parentTable;
    _this._viewDataStore = viewDataStore;
    Object.seal((0, _assertThisInitialized2.default)(_this));
    return _this;
  }
  /**
   * @internal
   */


  (0, _createClass2.default)(View, [{
    key: "selectRecords",

    /**
     * Select records from the view. Returns a {@link RecordQueryResult}.
     *
     * Consider using {@link useRecords} or {@link useRecordIds} instead, unless you need the
     * features of a QueryResult (e.g. `queryResult.getRecordById`). Record hooks handle
     * loading/unloading and updating your UI automatically, but manually `select`ing records is
     * useful for one-off data processing.
     *
     * @param opts Options for the query, such as sorts, fields, and record coloring. By
     * default, records will be coloured according to the view.
     * @example
     * ```js
     * import {useBase, useRecords} from '@airtable/blocks/UI';
     * import React from 'react';
     *
     * function TodoList() {
     *     const base = useBase();
     *     const table = base.getTableByName('Tasks');
     *     const view = table.getViewByName('Grid view');
     *
     *     const queryResult = view.selectRecords();
     *     const records = useRecords(queryResult);
     *
     *     return (
     *         <ul>
     *             {records.map(record => (
     *                 <li key={record.id}>
     *                     {record.name || 'Unnamed record'}
     *                 </li>
     *             ))}
     *         </ul>
     *     );
     * }
     * ```
     */
    value: function selectRecords() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var defaultedOpts = _objectSpread({}, opts, {
        recordColorMode: opts.recordColorMode === undefined ? RecordColoring.modes.byView(this) : opts.recordColorMode
      });

      return _table_or_view_query_result.default.__createOrReuseQueryResult(this, this._viewDataStore.parentRecordStore, defaultedOpts);
    }
    /**
     * Select and load records from the view. Returns a {@link RecordQueryResult} promise where
     * record data has been loaded.
     *
     * Consider using {@link useRecords} or {@link useRecordIds} instead, unless you need the
     * features of a QueryResult (e.g. `queryResult.getRecordById`). Record hooks handle
     * loading/unloading and updating your UI automatically, but manually `select`ing records is
     * useful for one-off data processing.
     *
     * Once you've finished with your query, remember to call `queryResult.unloadData()`.
     *
     * @param opts Options for the query, such as sorts, fields, and record coloring. By
     * default, records will be coloured according to the view.
     * @example
     * ```js
     * async function getRecordCountAsync(view) {
     *     const query = await view.selectRecordsAsync();
     *     const recordCount = query.recordIds.length;
     *     query.unloadData();
     *     return recordCount;
     * }
     * ```
     */

  }, {
    key: "selectRecordsAsync",
    value: function selectRecordsAsync() {
      var opts,
          queryResult,
          _args = arguments;
      return _regenerator.default.async(function selectRecordsAsync$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              opts = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};
              queryResult = this.selectRecords(opts);
              _context.next = 4;
              return _regenerator.default.awrap(queryResult.loadDataAsync());

            case 4:
              return _context.abrupt("return", queryResult);

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
    /**
     * Select the field order and visible fields from the view. Returns a
     * {@link ViewMetadataQueryResult}.
     *
     * Consider using {@link useViewMetadata} instead if you're creating a React UI. The
     * {@link useViewMetadata} hook handles loading/unloading and updating your UI automatically,
     * but manually `select`ing data is useful for one-off data processing.
     *
     * @example
     * ```js
     * async function loadMetadataForViewAsync(view) {
     *     const viewMetadata = view.selectMetadata();
     *     await viewMetadata.loadDataAsync();
     *
     *     console.log('Visible fields:');
     *     console.log(viewMetadata.visibleFields.map(field => field.name));
     *     // => ['Field 1', 'Field 2', 'Field 3']
     *
     *     console.log('All fields:');
     *     console.log(viewMetadata.allFields.map(field => field.name));
     *     // => ['Field 1', 'Field 2', 'Field 3', 'Hidden field 4']
     *
     *     viewMetadata.unloadData();
     * }
     * ```
     */

  }, {
    key: "selectMetadata",
    value: function selectMetadata() {
      return _view_metadata_query_result.default.__createOrReuseQueryResult(this, this._viewDataStore);
    }
    /**
     * Select and load the field order and visible fields from the view. Returns a
     * {@link ViewMetadataQueryResult} promise where the metadata has already been loaded.
     *
     * Consider using {@link useViewMetadata} instead if you're creating a React UI. The
     * {@link useViewMetadata} hook handles loading/unloading and updating your UI automatically,
     * but manually `select`ing data is useful for one-off data processing.
     *
     * @example
     * ```js
     * async function loadMetadataForViewAsync(view) {
     *     const viewMetadata = await view.selectMetadata();
     *
     *     console.log('Visible fields:');
     *     console.log(viewMetadata.visibleFields.map(field => field.name));
     *     // => ['Field 1', 'Field 2', 'Field 3']
     *
     *     console.log('All fields:');
     *     console.log(viewMetadata.allFields.map(field => field.name));
     *     // => ['Field 1', 'Field 2', 'Field 3', 'Hidden field 4']
     *
     *     viewMetadata.unloadData();
     * }
     * ```
     */

  }, {
    key: "selectMetadataAsync",
    value: function selectMetadataAsync() {
      var queryResult;
      return _regenerator.default.async(function selectMetadataAsync$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              queryResult = this.selectMetadata();
              _context2.next = 3;
              return _regenerator.default.awrap(queryResult.loadDataAsync());

            case 3:
              return _context2.abrupt("return", queryResult);

            case 4:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this);
    }
    /**
     * @internal
     */

  }, {
    key: "__triggerOnChangeForDirtyPaths",
    value: function __triggerOnChangeForDirtyPaths(dirtyPaths) {
      var didViewSchemaChange = false;

      this._viewDataStore.triggerOnChangeForDirtyPaths(dirtyPaths);

      if (dirtyPaths.name) {
        this._onChange(WatchableViewKeys.name);

        didViewSchemaChange = true;
      }

      return didViewSchemaChange;
    }
  }, {
    key: "_dataOrNullIfDeleted",
    get: function get() {
      var _ref;

      var tableData = this._baseData.tablesById[this.parentTable.id];
      return (_ref = tableData === null || tableData === void 0 ? void 0 : tableData.viewsById[this._id]) !== null && _ref !== void 0 ? _ref : null;
    }
    /**
     * The table that this view belongs to. Should never change because views aren't moved between tables.
     *
     * @internal (since we may not be able to return parent model instances in the immutable models world)
     * @example
     * ```js
     * const view = myTable.getViewByName('Grid View');
     * console.log(view.parentTable.id === myTable.id);
     * // => true
     * ```
     */

  }, {
    key: "parentTable",
    get: function get() {
      return this._parentTable;
    }
    /**
     * The name of the view. Can be watched.
     *
     * @example
     * ```js
     * console.log(myView.name);
     * // => 'Grid view'
     * ```
     */

  }, {
    key: "name",
    get: function get() {
      return this._data.name;
    }
    /**
     * The type of the view, such as Grid, Calendar, or Kanban. Should never change because view types cannot be modified.
     *
     * @example
     * ```js
     * console.log(myView.type);
     * // => 'kanban'
     * ```
     */

  }, {
    key: "type",
    get: function get() {
      return this._data.type;
    }
    /**
     * The URL for the view. You can visit this URL in the browser to be taken to the view in the Airtable UI.
     *
     * @example
     * ```js
     * console.log(myView.url);
     * // => 'https://airtable.com/tblxxxxxxxxxxxxxx/viwxxxxxxxxxxxxxx'
     * ```
     */

  }, {
    key: "url",
    get: function get() {
      return this.parentTable._airtableInterface.urlConstructor.getViewUrl(this.id, this.parentTable.id);
    }
  }]);
  return View;
}(_abstract_model.default);

(0, _defineProperty2.default)(View, "_className", 'View');
var _default = View;
exports.default = _default;