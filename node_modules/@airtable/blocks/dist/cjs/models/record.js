"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("core-js/modules/es.string.starts-with");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

require("regenerator-runtime/runtime");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _get_sdk = _interopRequireDefault(require("../get_sdk"));

var _field = require("../types/field");

var _private_utils = require("../private_utils");

var _error_utils = require("../error_utils");

var _color_utils = _interopRequireDefault(require("../color_utils"));

var _warning = _interopRequireDefault(require("../warning"));

var _abstract_model = _interopRequireDefault(require("./abstract_model"));

var _linked_records_query_result = _interopRequireDefault(require("./linked_records_query_result"));

/** @module @airtable/blocks/models: Record */

/** */
var WatchableRecordKeys = Object.freeze({
  name: 'name',
  // deprecated in favor of name:
  primaryCellValue: 'primaryCellValue',
  commentCount: 'commentCount',
  // TODO(kasra): these keys don't have matching getters (not that they should
  // it's just inconsistent...)
  cellValues: 'cellValues'
}); // TODO: load cell values in field when this is watched? This will
// cause the CellRenderer component to load cell values, which seems okay,
// but needs a little more thought.

var WatchableCellValueInFieldKeyPrefix = 'cellValueInField:'; // TODO: load view data when this is watched. see previous comment.

var WatchableColorInViewKeyPrefix = 'colorInView:';
/**
 * Any key within record that can be watched:
 * - `'name'`
 * - `'commentCount'`
 * - `'cellValues'`
 * - `'cellValueInField:' + someFieldId`
 * - `'colorInView:' + someViewId`
 */

/**
 * Model class representing a record in a table.
 *
 * Do not instantiate. You can get instances of this class by calling `table.selectRecords`
 * or `view.selectRecords` and using the resulting {@link RecordQueryResult}.
 *
 * @docsPath models/Record
 */
var Record =
/*#__PURE__*/
function (_AbstractModel) {
  (0, _inherits2.default)(Record, _AbstractModel);
  (0, _createClass2.default)(Record, null, [{
    key: "_isWatchableKey",
    // Once all blocks set this flag to true, remove this flag.

    /** @hidden */

    /** @internal */

    /** @internal */
    value: function _isWatchableKey(key) {
      return (0, _private_utils.isEnumValue)(WatchableRecordKeys, key) || key.startsWith(WatchableCellValueInFieldKeyPrefix) || key.startsWith(WatchableColorInViewKeyPrefix);
    }
    /** @internal */

  }]);

  /**
   * @internal
   */
  function Record(baseData, parentRecordStore, parentTable, recordId) {
    var _this;

    (0, _classCallCheck2.default)(this, Record);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Record).call(this, baseData, recordId));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_parentRecordStore", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_parentTable", void 0);
    _this._parentRecordStore = parentRecordStore;
    _this._parentTable = parentTable;
    return _this;
  }
  /**
   * @internal
   */


  (0, _createClass2.default)(Record, [{
    key: "_getFieldMatching",

    /**
     * @internal
     */
    value: function _getFieldMatching(fieldOrFieldIdOrFieldName) {
      return this.parentTable.__getFieldMatching(fieldOrFieldIdOrFieldName);
    }
    /**
     * @internal
     */

  }, {
    key: "_getViewMatching",
    value: function _getViewMatching(viewOrViewIdOrViewName) {
      return this.parentTable.__getViewMatching(viewOrViewIdOrViewName);
    }
    /**
     * Gets the cell value of the given field for this record.
     *
     * @param fieldOrFieldIdOrFieldName The field (or field ID or field name) whose cell value you'd like to get.
     * @example
     * ```js
     * const cellValue = myRecord.getCellValue(mySingleLineTextField);
     * console.log(cellValue);
     * // => 'cell value'
     * ```
     */

  }, {
    key: "getCellValue",
    value: function getCellValue(fieldOrFieldIdOrFieldName) {
      var field = this._getFieldMatching(fieldOrFieldIdOrFieldName);

      (0, _error_utils.invariant)(this._parentRecordStore.areCellValuesLoadedForFieldId(field.id), 'Cell values for field %s are not loaded', field.id);
      var cellValuesByFieldId = this._data.cellValuesByFieldId;

      if (!cellValuesByFieldId) {
        return null;
      }

      var cellValue = cellValuesByFieldId[field.id] !== undefined ? cellValuesByFieldId[field.id] : null;

      if (typeof cellValue === 'object' && cellValue !== null) {
        // HACK: while we migrate our blocks to the new lookup cell value
        // format, make the public cell value look like an array for
        // backwards compatibility.
        if (!Record.shouldUseNewLookupFormat && field.type === _field.FieldType.MULTIPLE_LOOKUP_VALUES) {
          var cellValueForMigration = [];
          cellValueForMigration.linkedRecordIds = (0, _private_utils.cloneDeep)(cellValue.linkedRecordIds);
          cellValueForMigration.valuesByLinkedRecordId = (0, _private_utils.cloneDeep)(cellValue.valuesByLinkedRecordId);
          (0, _error_utils.invariant)(Array.isArray(cellValue.linkedRecordIds), 'linkedRecordIds');
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = cellValue.linkedRecordIds[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var linkedRecordId = _step.value;
              (0, _error_utils.invariant)(typeof linkedRecordId === 'string', 'linkedRecordId');
              var _ref = cellValue,
                  valuesByLinkedRecordId = _ref.valuesByLinkedRecordId;
              (0, _error_utils.invariant)(valuesByLinkedRecordId && typeof valuesByLinkedRecordId === 'object', 'valuesByLinkedRecordId');
              var value = valuesByLinkedRecordId[linkedRecordId];

              if (Array.isArray(value)) {
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                  for (var _iterator2 = value[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var v = _step2.value;
                    cellValueForMigration.push(v);
                  }
                } catch (err) {
                  _didIteratorError2 = true;
                  _iteratorError2 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                      _iterator2.return();
                    }
                  } finally {
                    if (_didIteratorError2) {
                      throw _iteratorError2;
                    }
                  }
                }
              } else {
                cellValueForMigration.push(value);
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          return cellValueForMigration;
        } // Copy non-primitives.
        // TODO(kasra): maybe freezeDeep instead?


        return (0, _private_utils.cloneDeep)(cellValue);
      } else {
        return cellValue;
      }
    }
    /**
     * Gets the cell value of the given field for this record, formatted as a `string`.
     *
     * @param fieldOrFieldIdOrFieldName The field (or field ID or field name) whose cell value you'd like to get.
     * @example
     * ```js
     * const stringValue = myRecord.getCellValueAsString(myNumberField);
     * console.log(stringValue);
     * // => '42'
     * ```
     */

  }, {
    key: "getCellValueAsString",
    value: function getCellValueAsString(fieldOrFieldIdOrFieldName) {
      var field = this._getFieldMatching(fieldOrFieldIdOrFieldName);

      (0, _error_utils.invariant)(this._parentRecordStore.areCellValuesLoadedForFieldId(field.id), 'Cell values for field %s are not loaded', field.id);
      var cellValue = this.getCellValue(field.id);

      if (cellValue === null || cellValue === undefined) {
        return '';
      } else {
        var airtableInterface = (0, _get_sdk.default)().__airtableInterface;

        var appInterface = (0, _get_sdk.default)().__appInterface;

        return airtableInterface.fieldTypeProvider.convertCellValueToString(appInterface, cellValue, field._data);
      }
    }
    /**
     * Returns a URL that is suitable for rendering an attachment on the current client.
     * The URL that is returned will only work for the current user.
     *
     * @param attachmentId The ID of the attachment.
     * @param attachmentUrl The attachment's URL (which is not suitable for rendering on the client).
     * @example
     * ```js
     * import React from 'react';
     *
     * function RecordAttachments(props) {
     *     const {record, attachmentField} = props;
     *     const attachmentCellValue = record.getCellValue(attachmentField);
     *     if (attachmentCellValue === null) {
     *         return null;
     *     }
     *     return (
     *         <div>
     *             {attachmentCellValue.map(attachmentObj => {
     *                 const clientUrl =
     *                     record.getAttachmentClientUrlFromCellValueUrl(
     *                         attachmentObj.id,
     *                         attachmentObj.url
     *                     );
     *                 return (
     *                     <img key={attachmentObj.id} src={clientUrl} width={200} />
     *                 );
     *             })}
     *         </div>
     *     );
     * }
     * ```
     */

  }, {
    key: "getAttachmentClientUrlFromCellValueUrl",
    value: function getAttachmentClientUrlFromCellValueUrl(attachmentId, attachmentUrl) {
      var airtableInterface = (0, _get_sdk.default)().__airtableInterface;

      var appInterface = (0, _get_sdk.default)().__appInterface;

      return airtableInterface.urlConstructor.getAttachmentClientUrl(appInterface, attachmentId, attachmentUrl);
    }
    /**
     * Gets the color of this record in a given view, or null if the record has no color in that
     * view.
     *
     * Can be watched with the 'colorInView:${ViewId}' key.
     *
     * @param viewOrViewIdOrViewName The view (or view ID or view name) to use for record coloring.
     */

  }, {
    key: "getColorInView",
    value: function getColorInView(viewOrViewIdOrViewName) {
      var view = this._getViewMatching(viewOrViewIdOrViewName);

      return this._parentRecordStore.getViewDataStore(view.id).getRecordColor(this);
    }
    /**
     * Gets the CSS hex string for this record in a given view, or null if the record has no color
     * in that view.
     *
     * Can be watched with the 'colorInView:${ViewId}' key.
     *
     * @param viewOrViewIdOrViewName The view (or view ID or view name) to use for record coloring.
     */

  }, {
    key: "getColorHexInView",
    value: function getColorHexInView(viewOrViewIdOrViewName) {
      var color = this.getColorInView(viewOrViewIdOrViewName);

      if (!color) {
        return null;
      }

      return _color_utils.default.getHexForColor(color);
    }
    /**
     * Select records referenced in a `multipleRecordLinks` cell value. Returns a query result
     * containing the records in the given `multipleRecordLinks` field.
     * See {@link RecordQueryResult} for more.
     *
     * @param fieldOrFieldIdOrFieldName The `multipleRecordLinks` field (or field ID or field name) to use.
     * @param opts Options for the query, such as sorts and fields.
     */

  }, {
    key: "selectLinkedRecordsFromCell",
    value: function selectLinkedRecordsFromCell(fieldOrFieldIdOrFieldName) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var field = this._getFieldMatching(fieldOrFieldIdOrFieldName);

      return _linked_records_query_result.default.__createOrReuseQueryResult(this, field, opts);
    }
    /**
     * Select and load records referenced in a `multipleRecordLinks` cell value. Returns a query result
     * promise containing the records in the given `multipleRecordLinks` field.
     * See {@link RecordQueryResult} for more.
     *
     * Remember to call `queryResult.unloadData` once you're finished with the query.
     *
     * @param fieldOrFieldIdOrFieldName The `multipleRecordLinks` field (or field ID or field name) to use.
     * @param opts Options for the query, such as sorts and fields.
     */

  }, {
    key: "selectLinkedRecordsFromCellAsync",
    value: function selectLinkedRecordsFromCellAsync(fieldOrFieldIdOrFieldName) {
      var opts,
          queryResult,
          _args = arguments;
      return _regenerator.default.async(function selectLinkedRecordsFromCellAsync$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              queryResult = this.selectLinkedRecordsFromCell(fieldOrFieldIdOrFieldName, opts);
              _context.next = 4;
              return _regenerator.default.awrap(queryResult.loadDataAsync());

            case 4:
              return _context.abrupt("return", queryResult);

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
    /**
     * The URL for the record. You can visit this URL in the browser to be taken to the record in the Airtable UI.
     *
     * @example
     * ```js
     * console.log(myRecord.url);
     * // => 'https://airtable.com/tblxxxxxxxxxxxxxx/recxxxxxxxxxxxxxx'
     * ```
     */

  }, {
    key: "__triggerOnChangeForDirtyPaths",

    /**
     * @internal
     */
    value: function __triggerOnChangeForDirtyPaths(dirtyPaths) {
      var cellValuesByFieldId = dirtyPaths.cellValuesByFieldId,
          commentCount = dirtyPaths.commentCount;

      if (cellValuesByFieldId && !(0, _private_utils.isObjectEmpty)(cellValuesByFieldId)) {
        // TODO: don't trigger changes for fields that aren't supposed to be loaded
        // (in some cases, e.g. record created, liveapp will send cell values
        // that we're not subscribed to).
        this._onChange(WatchableRecordKeys.cellValues, Object.keys(cellValuesByFieldId));

        if (cellValuesByFieldId[this.parentTable.primaryField.id]) {
          this._onChange(WatchableRecordKeys.name); // deprecated in favor of name:


          this._onChange(WatchableRecordKeys.primaryCellValue);
        }

        for (var _i = 0, _Object$keys = Object.keys(cellValuesByFieldId); _i < _Object$keys.length; _i++) {
          var fieldId = _Object$keys[_i];

          this._onChange(WatchableCellValueInFieldKeyPrefix + fieldId, fieldId);
        }
      }

      if (commentCount) {
        this._onChange(WatchableRecordKeys.commentCount);
      }
    }
    /**
     * @internal
     */

  }, {
    key: "__triggerOnChangeForRecordColorInViewId",
    value: function __triggerOnChangeForRecordColorInViewId(viewId) {
      this._onChange(WatchableColorInViewKeyPrefix + viewId);
    }
  }, {
    key: "_dataOrNullIfDeleted",
    get: function get() {
      var _recordsById$this$_id;

      var tableData = this._baseData.tablesById[this.parentTable.id];

      if (!tableData) {
        return null;
      }

      var recordsById = tableData.recordsById;
      (0, _error_utils.invariant)(recordsById, 'Record data is not loaded');
      return (_recordsById$this$_id = recordsById[this._id]) !== null && _recordsById$this$_id !== void 0 ? _recordsById$this$_id : null;
    }
    /**
     * The table that this record belongs to. Should never change because records aren't moved between tables.
     *
     * @internal (since we may not be able to return parent model instances in the immutable models world)
     * @example
     * ```js
     * import {useRecords} from '@airtable/blocks/ui';
     * const records = useRecords(myTable);
     * console.log(records[0].parentTable.id === myTable.id);
     * // => true
     * ```
     */

  }, {
    key: "parentTable",
    get: function get() {
      return this._parentTable;
    }
  }, {
    key: "url",
    get: function get() {
      return this.parentTable._airtableInterface.urlConstructor.getRecordUrl(this.id, this.parentTable.id);
    }
    /** @hidden */

  }, {
    key: "primaryCellValue",
    get: function get() {
      (0, _warning.default)('record.primaryCellValue is deprecated. Use record.getCellValue(table.primaryField) instead.');
      return this.getCellValue(this.parentTable.primaryField);
    }
    /** @hidden */

  }, {
    key: "primaryCellValueAsString",
    get: function get() {
      (0, _warning.default)('record.primaryCellValueAsString is deprecated. Use record.name instead.');
      return this.name;
    }
    /**
     * The primary cell value in this record, formatted as a `string`.
     *
     * @example
     * ```js
     * console.log(myRecord.name);
     * // => '42'
     * ```
     */

  }, {
    key: "name",
    get: function get() {
      return this.getCellValueAsString(this.parentTable.primaryField);
    }
    /**
     * The number of comments on this record.
     *
     * @example
     * ```js
     * const commentCount = myRecord.commentCount;
     * const isSingular = commentCount === 1;
     * console.log(
     *     `This record has ${commentCount} comment${isSingular ? '' : 's'}`
     * );
     * ```
     */

  }, {
    key: "commentCount",
    get: function get() {
      return this._data.commentCount;
    }
    /**
     * The created time of this record.
     *
     * @example
     * ```js
     * console.log(`
     *     This record was created at ${myRecord.createdTime.toISOString()}
     * `);
     * ```
     */

  }, {
    key: "createdTime",
    get: function get() {
      return new Date(this._data.createdTime);
    }
  }]);
  return Record;
}(_abstract_model.default);

(0, _defineProperty2.default)(Record, "shouldUseNewLookupFormat", false);
(0, _defineProperty2.default)(Record, "_className", 'Record');
var _default = Record;
exports.default = _default;