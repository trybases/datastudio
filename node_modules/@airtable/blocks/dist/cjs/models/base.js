"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.map");

require("core-js/modules/es.map");

require("core-js/modules/es.object.to-string");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _private_utils = require("../private_utils");

var _error_utils = require("../error_utils");

var _table = _interopRequireDefault(require("./table"));

var _record_store = _interopRequireDefault(require("./record_store"));

var _abstract_model = _interopRequireDefault(require("./abstract_model"));

/** @module @airtable/blocks/models: Base */

/** */
// How these model classes work:
//
// The single instance of the Base class maintains a reference to a plain JS
// object that contains all the data (baseData). All the other model classes
// receive a reference to baseData and traverse it to expose the data.
//
// As changes come in from liveapp, Base will apply them to the plain JS object.
// Since the other model classes have a reference to the same object, they'll
// always be accessing the most up-to-date values.
//
// Be careful not to return a reference to any non-primitive subtree of baseData,
// since the block developer could mutate it and we'll end up out of sync with
// liveapp.
var WatchableBaseKeys = Object.freeze({
  name: 'name',
  tables: 'tables',
  collaborators: 'collaborators',
  schema: 'schema'
});
/**
 * Any key in base that can be watched:
 * - `name`: the name of the base
 * - `tables`: the order of tables in the base
 * - `collaborators`: all the collaborators in the base
 * - `schema`: the base schema (essentially everything except for record data)
 */

/**
 * Model class representing a base.
 *
 * If you want the base model to automatically recalculate whenever the base schema changes, try the
 * {@link useBase} hook. Alternatively, you can manually subscribe to changes with
 * {@link useWatchable} (recommended) or [Base#watch](/developers/blocks/api/models/Base#watch).
 *
 * @example
 * ```js
 * import {base} from '@airtable/blocks';
 *
 * console.log('The name of your base is', base.name);
 * ```
 * @docsPath models/Base
 */
var Base =
/*#__PURE__*/
function (_AbstractModel) {
  (0, _inherits2.default)(Base, _AbstractModel);
  (0, _createClass2.default)(Base, null, [{
    key: "_isWatchableKey",

    /** @internal */

    /** @internal */
    value: function _isWatchableKey(key) {
      return (0, _private_utils.isEnumValue)(WatchableBaseKeys, key);
    }
    /** @internal */

  }]);

  /**
   * @internal
   */
  function Base(baseData, airtableInterface) {
    var _this;

    (0, _classCallCheck2.default)(this, Base);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Base).call(this, baseData, baseData.id));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_tableModelsById", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_tableRecordStoresByTableId", {});
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_airtableInterface", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "__billingPlanGrouping", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_collaboratorIdsByNameAndEmail", null);
    _this._tableModelsById = {}; // Table instances are lazily created by getTableById.

    _this._airtableInterface = airtableInterface;
    _this.__billingPlanGrouping = baseData.billingPlanGrouping;
    return _this;
  }
  /**
   * @internal
   */


  (0, _createClass2.default)(Base, [{
    key: "getCollaboratorByIdIfExists",

    /**
     * The user matching the given ID, or `null` if that user does not exist or does not have access
     * to this base.
     *
     * @param collaboratorId The ID of the user.
     */
    value: function getCollaboratorByIdIfExists(collaboratorId) {
      var collaboratorsById = this._data.collaboratorsById;
      return (0, _private_utils.has)(collaboratorsById, collaboratorId) ? collaboratorsById[collaboratorId] : null;
    }
    /**
     * The user matching the given ID. Throws if that user does not exist
     * or does not have access to this base. Use {@link getCollaboratorByIdIfExists}
     * instead if you are unsure whether a collaborator with the given ID exists
     * and has access to this base.
     *
     * @param collaboratorId The ID of the user.
     */

  }, {
    key: "getCollaboratorById",
    value: function getCollaboratorById(collaboratorId) {
      var collaborator = this.getCollaboratorByIdIfExists(collaboratorId);

      if (!collaborator) {
        throw (0, _error_utils.spawnError)("No collaborator with ID %s has access to base '%s'", collaboratorId, this.name);
      }

      return collaborator;
    }
    /**
     * The user matching the given ID, name, or email address. Returns null if that user does not
     * exist or does not have access to this base.
     *
     * This method is convenient when building a block for a specific base, but for more generic
     * blocks the best practice is to use the {@link getCollaboratorByIdIfExists} method instead.
     *
     * @param collaboratorIdOrNameOrEmail The ID of the user.
     */

  }, {
    key: "getCollaboratorIfExists",
    value: function getCollaboratorIfExists(idOrNameOrEmail) {
      var collaboratorById = this.getCollaboratorByIdIfExists(idOrNameOrEmail);

      if (collaboratorById) {
        return collaboratorById;
      }

      if (!this._collaboratorIdsByNameAndEmail) {
        this._collaboratorIdsByNameAndEmail = new Map();
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = (0, _private_utils.entries)(this._data.collaboratorsById)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = (0, _slicedToArray2.default)(_step.value, 2),
                id = _step$value[0],
                _step$value$ = _step$value[1],
                email = _step$value$.email,
                name = _step$value$.name;

            this._collaboratorIdsByNameAndEmail.set(email, id); // we prevent `@` in names so theoretically we shouldn't encounter any collisions
            // between names and emails, but names themselves may not be unique. as we build the
            // name hash, we only add new values rather than overwrite existing ones. this means
            // that we'll prefer emails to names in the event of a collision.


            if (name && !this._collaboratorIdsByNameAndEmail.has(name)) {
              this._collaboratorIdsByNameAndEmail.set(name, id);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      var idForNameOrEmail = this._collaboratorIdsByNameAndEmail.get(idOrNameOrEmail);

      if (idForNameOrEmail !== undefined) {
        return this.getCollaboratorById(idForNameOrEmail);
      }

      return null;
    }
    /**
     * The user matching the given ID, name, or email address. Throws if that user does not exist
     * or does not have access to this base. Use {@link getCollaboratorIfExists} instead if you are
     * unsure whether a collaborator with the given ID exists and has access to this base.
     *
     * This method is convenient when building a block for a specific base, but for more generic
     * blocks the best practice is to use the {@link getCollaboratorById} method instead.
     *
     * @param collaboratorIdOrNameOrEmail The ID of the user.
     */

  }, {
    key: "getCollaborator",
    value: function getCollaborator(idOrNameOrEmail) {
      var collaborator = this.getCollaboratorIfExists(idOrNameOrEmail);

      if (!collaborator) {
        throw (0, _error_utils.spawnError)("No collaborator with ID, name, or email of '%s' is in base '%s'", idOrNameOrEmail, this.name);
      }

      return collaborator;
    }
    /**
     * @internal
     */

  }, {
    key: "__getRecordStore",
    value: function __getRecordStore(tableId) {
      if ((0, _private_utils.has)(this._tableRecordStoresByTableId, tableId)) {
        return this._tableRecordStoresByTableId[tableId];
      }

      (0, _error_utils.invariant)(this._data.tablesById[tableId], 'table must exist');
      var newRecordStore = new _record_store.default(this._baseData, this._airtableInterface, tableId);
      this._tableRecordStoresByTableId[tableId] = newRecordStore;
      return newRecordStore;
    }
    /**
     * @internal
     */

  }, {
    key: "__getBaseData",
    value: function __getBaseData() {
      return this._data;
    }
    /**
     * The table matching the given ID, or `null` if that table does not exist in this base.
     *
     * @param tableId The ID of the table.
     */

  }, {
    key: "getTableByIdIfExists",
    value: function getTableByIdIfExists(tableId) {
      if (!this._data.tablesById[tableId]) {
        return null;
      } else {
        if (!this._tableModelsById[tableId]) {
          this._tableModelsById[tableId] = new _table.default(this._data, this, this.__getRecordStore(tableId), tableId, this._airtableInterface);
        }

        return this._tableModelsById[tableId];
      }
    }
    /**
     * The table matching the given ID. Throws if that table does not exist in this base. Use
     * {@link getTableByIdIfExists} instead if you are unsure whether a table exists with the given
     * ID.
     *
     * @param tableId The ID of the table.
     */

  }, {
    key: "getTableById",
    value: function getTableById(tableId) {
      var table = this.getTableByIdIfExists(tableId);

      if (!table) {
        throw (0, _error_utils.spawnError)("No table with ID %s in base '%s'", tableId, this.name);
      }

      return table;
    }
    /**
     * The table matching the given name, or `null` if no table exists with that name in this base.
     *
     * @param tableName The name of the table you're looking for.
     */

  }, {
    key: "getTableByNameIfExists",
    value: function getTableByNameIfExists(tableName) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _private_utils.entries)(this._data.tablesById)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _step2$value = (0, _slicedToArray2.default)(_step2.value, 2),
              tableId = _step2$value[0],
              tableData = _step2$value[1];

          if (tableData.name === tableName) {
            return this.getTableByIdIfExists(tableId);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return null;
    }
    /**
     * The table matching the given name. Throws if no table exists with that name in this base. Use
     * {@link getTableByNameIfExists} instead if you are unsure whether a table exists with the
     * given name.
     *
     * @param tableName The name of the table you're looking for.
     */

  }, {
    key: "getTableByName",
    value: function getTableByName(tableName) {
      var table = this.getTableByNameIfExists(tableName);

      if (!table) {
        throw (0, _error_utils.spawnError)("No table named '%s' in base '%s'", tableName, this.name);
      }

      return table;
    }
    /**
     * The table matching the given ID or name. Returns `null` if no matching table exists within
     * this base.
     *
     * This method is convenient when building a block for a specific base, but for more generic
     * blocks the best practice is to use the {@link getTableByIdIfExists} or
     * {@link getTableByNameIfExists} methods instead.
     *
     * @param tableIdOrName The ID or name of the table you're looking for.
     */

  }, {
    key: "getTableIfExists",
    value: function getTableIfExists(tableIdOrName) {
      var _this$getTableByIdIfE;

      return (_this$getTableByIdIfE = this.getTableByIdIfExists(tableIdOrName)) !== null && _this$getTableByIdIfE !== void 0 ? _this$getTableByIdIfE : this.getTableByNameIfExists(tableIdOrName);
    }
    /**
     * The table matching the given ID or name. Throws if no matching table exists within this base.
     * Use {@link getTableIfExists} instead if you are unsure whether a table exists with the given
     * name/ID.
     *
     * This method is convenient when building a block for a specific base, but for more generic
     * blocks the best practice is to use the {@link getTableById} or {@link getTableByName} methods
     * instead.
     *
     * @param tableIdOrName The ID or name of the table you're looking for.
     */

  }, {
    key: "getTable",
    value: function getTable(tableIdOrName) {
      var table = this.getTableIfExists(tableIdOrName);

      if (!table) {
        throw (0, _error_utils.spawnError)("No table with ID or name '%s' in base '%s'", tableIdOrName, this.name);
      }

      return table;
    }
    /**
     * @internal
     */

  }, {
    key: "__triggerOnChangeForChangedPaths",
    value: function __triggerOnChangeForChangedPaths(changedPaths) {
      var didSchemaChange = false;

      if (changedPaths.name) {
        this._onChange(WatchableBaseKeys.name);

        didSchemaChange = true;
      }

      if (changedPaths.tableOrder) {
        this._onChange(WatchableBaseKeys.tables);

        didSchemaChange = true; // Clean up deleted tables

        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = (0, _private_utils.entries)(this._tableModelsById)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _step3$value = (0, _slicedToArray2.default)(_step3.value, 2),
                tableId = _step3$value[0],
                tableModel = _step3$value[1];

            if (tableModel.isDeleted) {
              delete this._tableModelsById[tableId];
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }

      var tablesById = changedPaths.tablesById;

      if (tablesById) {
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = (0, _private_utils.entries)(tablesById)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var _step4$value = (0, _slicedToArray2.default)(_step4.value, 2),
                _tableId = _step4$value[0],
                dirtyTablePaths = _step4$value[1];

            // Directly access from _tableModelsById to avoid creating
            // a table model if it doesn't already exist. If it doesn't exist,
            // nothing can be subscribed to any events on it.
            var table = this._tableModelsById[_tableId];

            if (table && dirtyTablePaths) {
              var didTableSchemaChange = table.__triggerOnChangeForDirtyPaths(dirtyTablePaths);

              if (didTableSchemaChange) {
                didSchemaChange = true;
              }
            }
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      }

      if (changedPaths.collaboratorsById || changedPaths.activeCollaboratorIds) {
        this._onChange(WatchableBaseKeys.collaborators);
      }

      if (changedPaths.appInterface) {
        didSchemaChange = true;
      }

      if (didSchemaChange) {
        this._onChange(WatchableBaseKeys.schema);
      }
    }
    /**
     * @internal
     */

  }, {
    key: "__applyChangesWithoutTriggeringEvents",
    value: function __applyChangesWithoutTriggeringEvents(changes) {
      // Internal method.
      // After applying all changes, changedPaths will have the same shape as
      // the subset of this._data that changed. For example, if some table's
      // name changes, changedPaths will be {tablesById: {tbl123: name: {_isDirty: true}}}.
      // Use it to call __triggerOnChangeForChangedPaths to trigger change events for
      // effected models
      var changedPaths = {};
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = changes[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var change = _step5.value;

          this._applyChange(change.path, change.value, changedPaths);
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return changedPaths;
    }
    /**
     * @internal
     */

  }, {
    key: "_applyChange",
    value: function _applyChange(path, value, changedPathsByRef) {
      var dataSubtree = this._data;
      var dirtySubtree = changedPathsByRef;

      for (var i = 0; i < path.length - 1; i++) {
        var part = path[i];

        if (!dataSubtree[part]) {
          // Certain fields are stored sparsely (e.g. cellValuesByFieldId),
          // so create an object on demand if needed.
          dataSubtree[part] = {};
        }

        dataSubtree = dataSubtree[part];

        if (!dirtySubtree[part]) {
          dirtySubtree[part] = {};
        }

        (0, _error_utils.invariant)(dirtySubtree[part], 'dirtySubtree');
        dirtySubtree = dirtySubtree[part];
      }

      var lastPathPart = path[path.length - 1];
      var didChange = !(0, _private_utils.isDeepEqual)(dataSubtree[lastPathPart], value);

      if (value === undefined) {
        delete dataSubtree[lastPathPart];
      } else {
        dataSubtree[lastPathPart] = value;
      }

      if (didChange) {
        if (!dirtySubtree[lastPathPart]) {
          dirtySubtree[lastPathPart] = {};
        }

        (0, _error_utils.invariant)(dirtySubtree[lastPathPart], 'dirtySubtree');
        dirtySubtree[lastPathPart]._isDirty = true;
      }
    }
  }, {
    key: "_dataOrNullIfDeleted",
    get: function get() {
      return this._baseData;
    }
    /**
     * The name of the base.
     *
     * @example
     * ```js
     * import {base} from '@airtable/blocks';
     * console.log('The name of your base is', base.name);
     * ```
     */

  }, {
    key: "name",
    get: function get() {
      return this._data.name;
    }
    /**
     * The tables in this base. Can be watched to know when tables are created, deleted, or reordered in the base.
     *
     * @example
     * ```js
     * import {base} from '@airtable/blocks';
     * console.log(`You have ${base.tables.length} tables`);
     * ```
     */

  }, {
    key: "tables",
    get: function get() {
      // TODO(kasra): cache and freeze this so it isn't O(n)
      var tables = [];

      this._data.tableOrder.forEach(tableId => {
        var table = this.getTableByIdIfExists(tableId); // NOTE: A table's ID may be in tableOrder without the table appearing
        // in tablesById, in which case getTableById will return null. This
        // happens if table was just created by the user, since we
        // wait for the push payload to deliver the table schema.

        if (table) {
          tables.push(table);
        }
      });

      return tables;
    }
    /**
     * The users who have access to this base.
     *
     * @example
     * ```js
     * import {base} from '@airtable/blocks';
     * console.log(base.activeCollaborators[0].email);
     * ```
     */

  }, {
    key: "activeCollaborators",
    get: function get() {
      return this._data.activeCollaboratorIds.map(collaboratorId => this.getCollaboratorById(collaboratorId));
    }
  }]);
  return Base;
}(_abstract_model.default);

(0, _defineProperty2.default)(Base, "_className", 'Base');
var _default = Base;
exports.default = _default;