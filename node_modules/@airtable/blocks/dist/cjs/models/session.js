"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.array.includes");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.string.includes");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _error_utils = require("../error_utils");

var _get_sdk = _interopRequireDefault(require("../get_sdk"));

var _private_utils = require("../private_utils");

var _mutations = require("../types/mutations");

var _abstract_model = _interopRequireDefault(require("./abstract_model"));

/** @module @airtable/blocks/models: Session */

/** */
var WatchableSessionKeys = Object.freeze({
  permissionLevel: 'permissionLevel',
  // NOTE: the current user's identity will never change, but their name/email/profile pic/etc. can.
  currentUser: 'currentUser'
});
/**
 * Watchable keys in {@link Session}.
 * - `currentUser`
 * - `permissionLevel`
 */

/**
 * Model class representing the current user's session.
 *
 * @example
 * ```js
 * import {session} from '@airtable/blocks';
 *
 * if (session.currentUser !== null) {
 *     console.log("The current user's name is", session.currentUser.name);
 * } else {
 *     console.log('This block is being viewed in a public share');
 * }
 * ```
 * @docsPath models/Session
 */
var Session =
/*#__PURE__*/
function (_AbstractModel) {
  (0, _inherits2.default)(Session, _AbstractModel);
  (0, _createClass2.default)(Session, null, [{
    key: "_isWatchableKey",

    /** @internal */

    /** @internal */
    value: function _isWatchableKey(key) {
      return (0, _private_utils.isEnumValue)(WatchableSessionKeys, key);
    }
    /** @internal */

  }]);

  /**
   * @internal
   */
  function Session(baseData, airtableInterface) {
    var _this;

    (0, _classCallCheck2.default)(this, Session);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Session).call(this, baseData, 'session'));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_airtableInterface", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_sessionData", void 0);
    _this._airtableInterface = airtableInterface;
    var permissionLevel = baseData.permissionLevel,
        currentUserId = baseData.currentUserId,
        enabledFeatureNames = baseData.enabledFeatureNames;
    _this._sessionData = {
      permissionLevel,
      currentUserId,
      enabledFeatureNames
    };
    Object.seal((0, _assertThisInitialized2.default)(_this));
    return _this;
  }
  /**
   * @internal
   */


  (0, _createClass2.default)(Session, [{
    key: "checkPermissionsForUpdateRecords",

    /**
     * Checks whether the current user has permission to update any records in the current base. For
     * more granular permission checks, see {@link Table.checkPermissionsForUpdateRecords}.
     *
     * Returns `{hasPermission: true}` if the current user can update records,
     * `{hasPermission: false, reasonDisplayString: string}` otherwise. `reasonDisplayString` may
     * be used to display an error message to the user.
     *
     * @example
     * ```js
     * import {session} from '@airtable/blocks';
     *
     * const updateRecordsCheckResult = session.checkPermissionsForUpdateRecords();
     * if (!updateRecordsCheckResult.hasPermission) {
     *     alert(updateRecordsCheckResult.reasonDisplayString);
     * }
     */
    value: function checkPermissionsForUpdateRecords() {
      return (0, _get_sdk.default)().__mutations.checkPermissionsForMutation({
        type: _mutations.MutationTypes.SET_MULTIPLE_RECORDS_CELL_VALUES,
        tableId: undefined,
        records: undefined
      });
    }
    /**
     * An alias for `session.checkPermissionsForUpdateRecords().hasPermission`. For more granular
     * permission checks, see {@link Table.hasPermissionToUpdateRecords}.
     */

  }, {
    key: "hasPermissionToUpdateRecords",
    value: function hasPermissionToUpdateRecords() {
      return this.checkPermissionsForUpdateRecords().hasPermission;
    }
    /**
     * Checks whether the current user has permission to create any records in the current base. For
     * more granular permission checks, see {@link Table.checkPermissionsForCreateRecords}.
     *
     * Returns `{hasPermission: true}` if the current user can create records,
     * `{hasPermission: false, reasonDisplayString: string}` otherwise. `reasonDisplayString` may be
     * used to display an error message to the user.
     *
     * @example
     * ```js
     * import {session} from '@airtable/blocks';
     *
     * const createRecordsCheckResult = session.checkPermissionsForCreateRecords();
     * if (!createRecordsCheckResult.hasPermission) {
     *     alert(createRecordsCheckResult.reasonDisplayString);
     * }
     */

  }, {
    key: "checkPermissionsForCreateRecords",
    value: function checkPermissionsForCreateRecords() {
      return (0, _get_sdk.default)().__mutations.checkPermissionsForMutation({
        type: _mutations.MutationTypes.CREATE_MULTIPLE_RECORDS,
        tableId: undefined,
        records: undefined
      });
    }
    /**
     * An alias for `session.checkPermissionsForCreateRecords().hasPermission`. For more granular
     * permission checks, see {@link Table.hasPermissionToCreateRecords}.
     */

  }, {
    key: "hasPermissionToCreateRecords",
    value: function hasPermissionToCreateRecords() {
      return this.checkPermissionsForCreateRecords().hasPermission;
    }
    /**
     * Checks whether the current user has permission to delete any records in the current base. For
     * more granular permission checks, see {@link Table.checkPermissionsForDeleteRecords}.
     *
     * Returns `{hasPermission: true}` if the current user can delete records,
     * `{hasPermission: false, reasonDisplayString: string}` otherwise. `reasonDisplayString` may be
     * used to display an error message to the user.
     *
     * @example
     * ```js
     * import {session} from '@airtable/blocks';
     *
     * const deleteRecordsCheckResult = session.checkPermissionsForDeleteRecords();
     * if (!deleteRecordsCheckResult.hasPermission) {
     *     alert(deleteRecordsCheckResult.reasonDisplayString);
     * }
     */

  }, {
    key: "checkPermissionsForDeleteRecords",
    value: function checkPermissionsForDeleteRecords() {
      return (0, _get_sdk.default)().__mutations.checkPermissionsForMutation({
        type: _mutations.MutationTypes.DELETE_MULTIPLE_RECORDS,
        tableId: undefined,
        recordIds: undefined
      });
    }
    /**
     * An alias for `session.checkPermissionsForDeleteRecords().hasPermission`. For more granular
     * permission checks, see {@link Table.hasPermissionToDeleteRecords}.
     */

  }, {
    key: "hasPermissionToDeleteRecords",
    value: function hasPermissionToDeleteRecords() {
      return this.checkPermissionsForDeleteRecords().hasPermission;
    }
    /**
     * @internal
     */

  }, {
    key: "__isFeatureEnabled",

    /**
     * @internal
     */
    value: function __isFeatureEnabled(featureName) {
      return this._sessionData.enabledFeatureNames.includes(featureName);
    }
    /**
     * @internal
     */

  }, {
    key: "__applyChangesWithoutTriggeringEvents",
    value: function __applyChangesWithoutTriggeringEvents(changes) {
      var changedKeys = {
        [WatchableSessionKeys.permissionLevel]: false,
        [WatchableSessionKeys.currentUser]: false
      };
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = changes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = _step.value,
              path = _step$value.path,
              value = _step$value.value;

          if (path[0] === 'permissionLevel') {
            (0, _error_utils.invariant)(path.length === 1, 'cannot set within permissionLevel'); // NOTE: just verify that the permission level is a string (rather than
            // checking isEnumValue against PermissionLevels) in case new permission
            // levels are added on the liveapp side. Permissions behavior gets routed
            // through the checkPermissionsForMutation AirtableInterface helper, so we
            // should still be able to handle unknown permission levels.

            (0, _error_utils.invariant)(typeof value === 'string', 'permissionLevel must be a string');
            this._sessionData.permissionLevel = value;
            changedKeys[WatchableSessionKeys.permissionLevel] = true;
          } // TODO(emma): fire change only when the current user's info changes


          if (path[0] === 'collaboratorsById') {
            changedKeys[WatchableSessionKeys.currentUser] = true;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return changedKeys;
    }
    /**
     * @internal
     */

  }, {
    key: "__triggerOnChangeForChangedKeys",
    value: function __triggerOnChangeForChangedKeys(changedKeys) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _private_utils.entries)(changedKeys)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _step2$value = (0, _slicedToArray2.default)(_step2.value, 2),
              key = _step2$value[0],
              didChange = _step2$value[1];

          if (didChange) {
            this._onChange(key);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: "_dataOrNullIfDeleted",
    get: function get() {
      return this._sessionData;
    }
    /**
     * The current user, or `null` if the block is running in a publicly shared base.
     *
     * @example
     * ```js
     * import {session} from '@airtable/blocks';
     * if (session.currentUser) {
     *     console.log(session.currentUser.id);
     *     console.log(session.currentUser.email);
     *     console.log(session.currentUser.name);
     * }
     * ```
     */

  }, {
    key: "currentUser",
    get: function get() {
      var userId = this._sessionData.currentUserId;

      if (!userId) {
        return null;
      } else {
        var _getSdk = (0, _get_sdk.default)(),
            base = _getSdk.base;

        return base.getCollaboratorByIdIfExists(userId);
      }
    }
  }, {
    key: "__currentUserId",
    get: function get() {
      return this._sessionData.currentUserId;
    }
    /**
     * @internal
     */

  }, {
    key: "__rawPermissionLevel",
    get: function get() {
      return this._sessionData.permissionLevel;
    }
  }]);
  return Session;
}(_abstract_model.default);

(0, _defineProperty2.default)(Session, "_className", 'Session');
var _default = Session;
exports.default = _default;