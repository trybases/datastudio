"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

require("regenerator-runtime/runtime");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _private_utils = require("../private_utils");

var _error_utils = require("../error_utils");

var _abstract_model_with_async_data = _interopRequireDefault(require("./abstract_model_with_async_data"));

var _table = _interopRequireDefault(require("./table"));

var _view = _interopRequireDefault(require("./view"));

var _record = _interopRequireDefault(require("./record"));

/** @module @airtable/blocks/models: Cursor */

/** */
var WatchableCursorKeys = Object.freeze({
  selectedRecordIds: 'selectedRecordIds',
  selectedFieldIds: 'selectedFieldIds',
  activeTableId: 'activeTableId',
  activeViewId: 'activeViewId',
  isDataLoaded: 'isDataLoaded'
});
/**
 * Watchable keys in {@link Cursor}.
 * - `selectedRecordIds`
 * - `selectedFieldIds`
 * - `activeTableId`
 * - `activeViewId`
 * - `isDataLoaded`
 */

// NOTE: cursor is an AbstractModel because it includes loadable data.

/**
 * Model class containing information about the state of the user's current interactions in
 * Airtable - specifically, their active table, active view, selected records and selected fields.
 * Also allows you to set the active table and active view.
 *
 * Selected records and fields are not loaded by default and the cursor must be loaded with
 * {@link useLoadable} to access them.
 *
 * ```js
 * import {cursor} from '@airtable/blocks';
 * import {useWatchable} from '@airtable/blocks/ui';
 *
 *  function ActiveTableAndView() {
 *      // re-render whenever the active table or view changes
 *      useWatchable(cursor, ['activeTableId', 'activeViewId']);
 *
 *      return (
 *          <div>
 *              Active table: {cursor.activeTableId)}
 *              Active view: {cursor.activeViewId}
 *          </div>
 *      );
 *  }
 * ```
 *
 * ```js
 * import {cursor} from '@airtable/blocks';
 * import {useLoadable, useWatchable} from '@airtable/blocks/ui';
 *
 *  function SelectedRecordAndFieldIds() {
 *      // load selected records and fields
 *      useLoadable(cursor);
 *
 *      // re-render whenever the list of selected records or fields changes
 *      useWatchable(cursor, ['selectedRecordIds', 'selectedFieldIds']);
 *
 *      return (
 *          <div>
 *              Selected records: {cursor.selectedRecordIds.join(', ')}
 *              Selected fields: {cursor.selectedFieldIds.join(', ')}
 *          </div>
 *      );
 *  }
 * ```
 *
 * @docsPath models/Cursor
 */
var Cursor =
/*#__PURE__*/
function (_AbstractModelWithAsy) {
  (0, _inherits2.default)(Cursor, _AbstractModelWithAsy);
  (0, _createClass2.default)(Cursor, null, [{
    key: "_isWatchableKey",

    /** @internal */

    /** @internal */
    value: function _isWatchableKey(key) {
      return (0, _private_utils.isEnumValue)(WatchableCursorKeys, key);
    }
    /** @internal */

  }, {
    key: "_shouldLoadDataForKey",
    value: function _shouldLoadDataForKey(key) {
      return true;
    }
    /** @internal */

  }]);

  /** @internal */
  function Cursor(baseData, airtableInterface) {
    var _ref, _baseData$cursorData, _ref2, _baseData$cursorData2;

    var _this;

    (0, _classCallCheck2.default)(this, Cursor);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Cursor).call(this, baseData, 'cursor'));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_airtableInterface", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_cursorData", void 0);
    _this._airtableInterface = airtableInterface;
    var selectedRecordIdSet = (_ref = (_baseData$cursorData = baseData.cursorData) === null || _baseData$cursorData === void 0 ? void 0 : _baseData$cursorData.selectedRecordIdSet) !== null && _ref !== void 0 ? _ref : null;
    var selectedFieldIdSet = (_ref2 = (_baseData$cursorData2 = baseData.cursorData) === null || _baseData$cursorData2 === void 0 ? void 0 : _baseData$cursorData2.selectedFieldIdSet) !== null && _ref2 !== void 0 ? _ref2 : null;
    var activeTableId = baseData.activeTableId;
    var activeViewId = activeTableId ? baseData.tablesById[activeTableId].activeViewId : null;
    _this._cursorData = {
      selectedRecordIdSet,
      selectedFieldIdSet,
      activeTableId,
      activeViewId
    };
    Object.seal((0, _assertThisInitialized2.default)(_this));
    return _this;
  }
  /**
   * @internal
   */


  (0, _createClass2.default)(Cursor, [{
    key: "_onChangeIsDataLoaded",

    /**
     * @internal
     */
    value: function _onChangeIsDataLoaded() {
      this._onChange(WatchableCursorKeys.isDataLoaded);
    }
    /**
     * @internal
     */

  }, {
    key: "_loadDataAsync",
    value: function _loadDataAsync() {
      var cursorData;
      return _regenerator.default.async(function _loadDataAsync$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _regenerator.default.awrap(this._airtableInterface.fetchAndSubscribeToCursorDataAsync());

            case 2:
              cursorData = _context.sent;
              this._cursorData.selectedRecordIdSet = cursorData.selectedRecordIdSet;
              this._cursorData.selectedFieldIdSet = cursorData.selectedFieldIdSet;
              return _context.abrupt("return", [WatchableCursorKeys.selectedRecordIds, WatchableCursorKeys.selectedFieldIds]);

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
    /**
     * @internal
     */

  }, {
    key: "_unloadData",
    value: function _unloadData() {
      this._airtableInterface.unsubscribeFromCursorData();

      this._cursorData.selectedRecordIdSet = null;
      this._cursorData.selectedFieldIdSet = null;
    }
    /**
     * The record IDs of all currently selected records, or an empty array if no records are selected.
     *
     * Not loaded by default. You must load cursor data with `useLoadable(cursor)` (recommended) or
     * `cursor.loadDataAsync()` before use.
     *
     * Can be watched.
     */

  }, {
    key: "isRecordSelected",

    /**
     * Checks whether a given record is selected.
     *
     * Selected records are not loaded by default. You must load cursor data with
     * `useLoadable(cursor)` (recommended) or `cursor.loadDataAsync()` before use.
     *
     * @param recordOrRecordId The record or record ID to check for.
     */
    value: function isRecordSelected(recordOrRecordId) {
      var selectedRecordIdSet = this._data.selectedRecordIdSet;
      (0, _error_utils.invariant)(selectedRecordIdSet, 'Cursor data is not loaded');
      var recordId;

      if (recordOrRecordId instanceof _record.default) {
        recordId = recordOrRecordId.id;
      } else {
        recordId = recordOrRecordId;
      }

      return !!selectedRecordIdSet[recordId];
    }
    /**
     * The currently active table ID. Can be null when the active table has changed and is not yet
     * loaded, and can also refer to a table that is not yet loaded.
     *
     * When fetching the {@link Table}, use `base.getTableByIdIfExists(cursor.activeTableId)` and
     * check the return value is not `null` to be resilient to those cases.
     *
     * Can be watched.
     */

  }, {
    key: "setActiveTable",

    /**
     * Sets the specified table to active in the Airtable UI. If the blocks pane is fullscreen, the
     * table will still be set as active, but the blocks pane will continue to be displayed
     * fullscreen.
     *
     * @param tableOrTableId The target table or table ID to set as active in the Airtable main page.
     */
    value: function setActiveTable(tableOrTableId) {
      var tableId = tableOrTableId instanceof _table.default ? tableOrTableId.id : tableOrTableId;

      this._airtableInterface.setActiveViewOrTable(tableId);
    }
    /**
     * Sets the specified view (and corresponding table) to active in the Airtable UI. If the blocks
     * pane is fullscreen, the view will still be set as active, but the blocks pane will continue
     * to be displayed fullscreen.
     *
     * @param tableOrTableId The table or table ID that the target view belongs to.
     * @param viewOrViewId The target view or view ID to set as active in the Airtable main page.
     */

  }, {
    key: "setActiveView",
    value: function setActiveView(tableOrTableId, viewOrViewId) {
      var tableId = tableOrTableId instanceof _table.default ? tableOrTableId.id : tableOrTableId;
      var viewId = viewOrViewId instanceof _view.default ? viewOrViewId.id : viewOrViewId;

      this._airtableInterface.setActiveViewOrTable(tableId, viewId);
    }
    /**
     * @internal
     */

  }, {
    key: "__applyChangesWithoutTriggeringEvents",
    value: function __applyChangesWithoutTriggeringEvents(changes) {
      var changedKeys = {
        [WatchableCursorKeys.selectedRecordIds]: false,
        [WatchableCursorKeys.activeTableId]: false,
        [WatchableCursorKeys.activeViewId]: false
      };
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = changes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = _step.value,
              path = _step$value.path,
              value = _step$value.value;

          if (path[0] === 'cursorData') {
            switch (path[1]) {
              case 'selectedRecordIdSet':
                {
                  (0, _error_utils.invariant)(path.length === 2, 'cannot set within selectedRecordIdSet');
                  this._cursorData.selectedRecordIdSet = value;
                  changedKeys[WatchableCursorKeys.selectedRecordIds] = true;
                  break;
                }

              case 'selectedFieldIdSet':
                {
                  (0, _error_utils.invariant)(path.length === 2, 'cannot set within selectedFieldIdSet');
                  this._cursorData.selectedFieldIdSet = value;
                  changedKeys[WatchableCursorKeys.selectedFieldIds] = true;
                  break;
                }

              default: // No-op for future unknown paths.

            }
          }

          if (path[0] === 'activeTableId') {
            (0, _error_utils.invariant)(value === null || typeof value === 'string', 'activeTableId must be string or null');
            this._cursorData.activeTableId = value;
            changedKeys[WatchableCursorKeys.activeTableId] = true;

            if (value === null) {
              this._cursorData.activeViewId = null;
              changedKeys[WatchableCursorKeys.activeViewId] = true;
            }
          }

          if (path[0] === 'tablesById' && path[1] === this.activeTableId && path[2] === 'activeViewId') {
            (0, _error_utils.invariant)(value === null || typeof value === 'string', 'activeTableId must be string or null');
            this._cursorData.activeViewId = value;
            changedKeys[WatchableCursorKeys.activeViewId] = true;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return changedKeys;
    }
    /**
     * @internal
     */

  }, {
    key: "__triggerOnChangeForChangedKeys",
    value: function __triggerOnChangeForChangedKeys(changedKeys) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _private_utils.entries)(changedKeys)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _step2$value = (0, _slicedToArray2.default)(_step2.value, 2),
              key = _step2$value[0],
              didChange = _step2$value[1];

          if (didChange) {
            this._onChange(key);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: "_dataOrNullIfDeleted",
    get: function get() {
      return this._cursorData;
    }
  }, {
    key: "selectedRecordIds",
    get: function get() {
      var selectedRecordIdSet = this._data.selectedRecordIdSet;
      (0, _error_utils.invariant)(selectedRecordIdSet, 'Cursor data is not loaded');
      var selectedRecordIds = Object.keys(selectedRecordIdSet);
      return selectedRecordIds;
    }
    /**
     * The field IDs of all currently selected fields, or an empty array if no fields are selected.
     *
     * Not loaded by default: you must load cursor data with `useLoadable(cursor)` (recommended) or
     * `cursor.loadDataAsync()` before use.
     *
     * Can be watched.
     */

  }, {
    key: "selectedFieldIds",
    get: function get() {
      var selectedFieldIdSet = this._data.selectedFieldIdSet;
      (0, _error_utils.invariant)(selectedFieldIdSet, 'Cursor data is not loaded');
      var selectedRecordIds = Object.keys(selectedFieldIdSet);
      return selectedRecordIds;
    }
  }, {
    key: "activeTableId",
    get: function get() {
      return this._data.activeTableId;
    }
    /**
     * The currently active view ID. This will always be a view belonging to `activeTableId`. Can be
     * null when the active view has changed and is not yet loaded, and can also refer to a view
     * that is not yet loaded.
     *
     * When fetching the {@link View}, use `table.getViewByIdIfExists(cursor.activeViewId)` and
     * check the return value is not `null` to be resilient to those cases.
     *
     * Can be watched.
     */

  }, {
    key: "activeViewId",
    get: function get() {
      return this._data.activeViewId;
    }
  }]);
  return Cursor;
}(_abstract_model_with_async_data.default);

(0, _defineProperty2.default)(Cursor, "_className", 'Cursor');
var _default = Cursor;
exports.default = _default;