"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.flat-map");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.unscopables.flat-map");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("core-js/modules/es.set");

require("core-js/modules/web.dom-collections.iterator");

require("core-js/modules/web.url.to-json");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

require("regenerator-runtime/runtime");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _get_sdk = _interopRequireDefault(require("../get_sdk"));

var _mutations = require("../types/mutations");

var _private_utils = require("../private_utils");

var _error_utils = require("../error_utils");

// Limit for how many items can be updated from a single batch mutation.
// This is number of records for MULTIPLE_RECORDS type mutations, and number of global config paths
// for SET_MULTIPLE_GLOBAL_CONFIG_PATHS.
// Same limit is enforced liveapp-side
var MUTATIONS_MAX_BATCH_SIZE = 50; // Liveapp requests must be under 2mb in size: we enforce a 1.9mb limit here to allow space for
// the other parts of the request

var MUTATIONS_MAX_BODY_SIZE = 1.9 * 1024 * 1024;
var MUTATION_HOLD_FOR_MS = 100;
/** @internal */

var Mutations =
/*#__PURE__*/
function () {
  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @hidden */
  function Mutations(airtableInterface, session, base, applyModelChanges, applyGlobalConfigUpdates) {
    (0, _classCallCheck2.default)(this, Mutations);
    (0, _defineProperty2.default)(this, "_airtableInterface", void 0);
    (0, _defineProperty2.default)(this, "_session", void 0);
    (0, _defineProperty2.default)(this, "_base", void 0);
    (0, _defineProperty2.default)(this, "_applyModelChanges", void 0);
    (0, _defineProperty2.default)(this, "_applyGlobalConfigUpdates", void 0);
    this._airtableInterface = airtableInterface;
    this._session = session;
    this._base = base;
    this._applyModelChanges = applyModelChanges;
    this._applyGlobalConfigUpdates = applyGlobalConfigUpdates;
  }
  /** @hidden */


  (0, _createClass2.default)(Mutations, [{
    key: "applyMutationAsync",
    value: function applyMutationAsync(mutation) {
      var permissionCheck, didApplyOptimisticUpdates;
      return _regenerator.default.async(function applyMutationAsync$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              this._assertMutationIsValid(mutation); // Limit check is after validity check so that we display errors for when users pass in
              // objects correctly (eg updating linked records cell value to be a record object) -
              // otherwise the limit check will fail due to circular objects being converted to JSON first


              this._assertMutationUnderLimits(mutation);

              permissionCheck = this.checkPermissionsForMutation(mutation);

              if (permissionCheck.hasPermission) {
                _context.next = 5;
                break;
              }

              throw (0, _error_utils.spawnError)('Cannot apply %s mutation: %s', mutation.type, permissionCheck.reasonDisplayString);

            case 5:
              didApplyOptimisticUpdates = this._applyOptimisticUpdatesForMutation(mutation);
              _context.prev = 6;
              _context.next = 9;
              return _regenerator.default.awrap(this._airtableInterface.applyMutationAsync(mutation, {
                holdForMs: MUTATION_HOLD_FOR_MS
              }));

            case 9:
              _context.next = 20;
              break;

            case 11:
              _context.prev = 11;
              _context.t0 = _context["catch"](6);

              if (!didApplyOptimisticUpdates) {
                _context.next = 19;
                break;
              }

              // if we applied optimistic updates, we can't gracefully handle a promise rejection
              // here - we can't un-apply optimistic updates, so the SDK's internal data model is
              // in an unexpected state. Instead of letting this promise get rejected, throw an
              // error after an async gap to crash the block, and make this promise await
              // something that will never resolve so we don't run any of the developers error-
              // handling code.
              setTimeout(() => {
                throw _context.t0;
              }, 0);
              _context.next = 17;
              return _regenerator.default.awrap(new Promise(() => {}));

            case 17:
              _context.next = 20;
              break;

            case 19:
              throw _context.t0;

            case 20:
            case "end":
              return _context.stop();
          }
        }
      }, null, this, [[6, 11]]);
    }
    /** @hidden */

  }, {
    key: "checkPermissionsForMutation",
    value: function checkPermissionsForMutation(mutation) {
      return this._airtableInterface.checkPermissionsForMutation(mutation, this._base.__getBaseData());
    }
    /** @internal */

  }, {
    key: "_assertMutationUnderLimits",
    value: function _assertMutationUnderLimits(mutation) {
      // Two limits to check here:
      // - for record-related mutations, it isn't above MUTATIONS_MAX_BATCH_SIZE
      // - mutation payload size won't exceed liveapp request payload size limit
      // Requests are sent as form-encoded utf-8 (1 byte characters)
      if (encodeURIComponent(JSON.stringify(mutation)).length > MUTATIONS_MAX_BODY_SIZE) {
        throw (0, _error_utils.spawnError)('Request exceeds maximum size limit of %s bytes', MUTATIONS_MAX_BODY_SIZE);
      }

      if (this._doesMutationExceedBatchSizeLimit(mutation)) {
        throw (0, _error_utils.spawnError)('Request exceeds maximum batch size limit of %s items', MUTATIONS_MAX_BATCH_SIZE);
      }
    }
    /** @internal */

  }, {
    key: "_doesMutationExceedBatchSizeLimit",
    value: function _doesMutationExceedBatchSizeLimit(mutation) {
      switch (mutation.type) {
        case _mutations.MutationTypes.SET_MULTIPLE_RECORDS_CELL_VALUES:
        case _mutations.MutationTypes.CREATE_MULTIPLE_RECORDS:
          return mutation.records.length > MUTATIONS_MAX_BATCH_SIZE;

        case _mutations.MutationTypes.DELETE_MULTIPLE_RECORDS:
          return mutation.recordIds.length > MUTATIONS_MAX_BATCH_SIZE;

        case _mutations.MutationTypes.SET_MULTIPLE_GLOBAL_CONFIG_PATHS:
          return mutation.updates.length > MUTATIONS_MAX_BATCH_SIZE;

        default:
          return false;
      }
    }
    /** @internal */

  }, {
    key: "_assertFieldIsValidForMutation",
    value: function _assertFieldIsValidForMutation(field) {
      if (field.isComputed) {
        throw (0, _error_utils.spawnError)("Can't set cell values: Field '%s' is computed and cannot be set", field.name);
      }
    }
    /** @internal */

  }, {
    key: "_assertMutationIsValid",
    value: function _assertMutationIsValid(mutation) {
      // We call validate the data (including any cell values) because if the data required for
      // us to do that is already loaded in the block, we can error out before applying
      // optimistic updates or sending the update to liveapp. That means that the error is
      // recoverable. Once we apply optimistic updates, if liveapp rejects the update then we
      // can't recover from that - we have to crash the block. We _could_ skip over these
      // validations - it wouldn't cause issues outside of the block frame. But running them
      // gives us slightly more confidence that we can do something other than completely crash
      // the block in the event of an invalid mutation.
      var airtableInterface = (0, _get_sdk.default)().__airtableInterface;

      var appInterface = (0, _get_sdk.default)().__appInterface;

      switch (mutation.type) {
        case _mutations.MutationTypes.SET_MULTIPLE_RECORDS_CELL_VALUES:
          {
            var tableId = mutation.tableId,
                records = mutation.records;

            var table = this._base.getTableByIdIfExists(tableId);

            if (!table) {
              throw (0, _error_utils.spawnError)("Can't set cell values: No table with id %s exists", tableId);
            } // For every mutation, we check that we're not trying to set fields that we don't support
            // mutations for yet. When record data is loaded, we also check that the record we're
            // updating actually exists and that the cell values are valid.


            var recordStore = this._base.__getRecordStore(tableId);

            var checkedFieldIds = new Set();
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = records[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var record = _step.value;
                var existingRecord = null;

                if (recordStore.isRecordMetadataLoaded) {
                  existingRecord = recordStore.getRecordByIdIfExists(record.id);

                  if (!existingRecord) {
                    throw (0, _error_utils.spawnError)("Can't set cell values: No record with id %s exists", record.id);
                  }
                }

                for (var _i = 0, _Object$keys = Object.keys(record.cellValuesByFieldId); _i < _Object$keys.length; _i++) {
                  var fieldId = _Object$keys[_i];
                  var field = table.getFieldByIdIfExists(fieldId);

                  if (!field) {
                    throw (0, _error_utils.spawnError)("Can't set cell values: No field with id %s exists in table '%s'", fieldId, table.name);
                  }

                  if (!checkedFieldIds.has(fieldId)) {
                    this._assertFieldIsValidForMutation(field);

                    checkedFieldIds.add(fieldId);
                  }

                  if (existingRecord && recordStore.areCellValuesLoadedForFieldId(fieldId)) {
                    var validationResult = airtableInterface.fieldTypeProvider.validateCellValueForUpdate(appInterface, record.cellValuesByFieldId[fieldId], existingRecord.getCellValue(fieldId), field._data);

                    if (!validationResult.isValid) {
                      throw (0, _error_utils.spawnError)("Can't set cell values: invalid cell value for field '%s'.\n%s", field.name, validationResult.reason);
                    }
                  }
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            return;
          }

        case _mutations.MutationTypes.DELETE_MULTIPLE_RECORDS:
          {
            var _tableId = mutation.tableId,
                recordIds = mutation.recordIds;

            var _table = this._base.getTableByIdIfExists(_tableId);

            if (!_table) {
              throw (0, _error_utils.spawnError)("Can't delete records: No table with id %s exists", _tableId);
            }

            var _recordStore = this._base.__getRecordStore(_tableId);

            if (_recordStore.isRecordMetadataLoaded) {
              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = undefined;

              try {
                for (var _iterator2 = recordIds[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  var recordId = _step2.value;

                  var _record = _recordStore.getRecordByIdIfExists(recordId);

                  if (!_record) {
                    throw (0, _error_utils.spawnError)("Can't delete records: No record with id %s exists in table '%s'", recordId, _table.name);
                  }
                }
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                    _iterator2.return();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }
            }

            return;
          }

        case _mutations.MutationTypes.CREATE_MULTIPLE_RECORDS:
          {
            var _tableId2 = mutation.tableId,
                _records = mutation.records;

            var _checkedFieldIds = new Set();

            var _table2 = this._base.getTableByIdIfExists(_tableId2);

            if (!_table2) {
              throw (0, _error_utils.spawnError)("Can't create records: No table with id %s exists", _tableId2);
            }

            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = _records[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var _record2 = _step3.value;

                for (var _i2 = 0, _Object$keys2 = Object.keys(_record2.cellValuesByFieldId); _i2 < _Object$keys2.length; _i2++) {
                  var _fieldId = _Object$keys2[_i2];

                  var _field = _table2.getFieldByIdIfExists(_fieldId);

                  if (!_field) {
                    throw (0, _error_utils.spawnError)("Can't create records: No field with id %s exists in table '%s'", _fieldId, _table2.name);
                  }

                  if (!_checkedFieldIds.has(_fieldId)) {
                    this._assertFieldIsValidForMutation(_field);

                    _checkedFieldIds.add(_fieldId);
                  } // Current cell value is null since the record doesn't exist.


                  var _validationResult = airtableInterface.fieldTypeProvider.validateCellValueForUpdate(appInterface, _record2.cellValuesByFieldId[_fieldId], null, _field._data);

                  if (!_validationResult.isValid) {
                    throw (0, _error_utils.spawnError)("Can't create records: invalid cell value for field '%s'.\n%s", _field.name, _validationResult.reason);
                  }
                }
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                  _iterator3.return();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }

            return;
          }

        case _mutations.MutationTypes.SET_MULTIPLE_GLOBAL_CONFIG_PATHS:
          {
            // globalConfig update is a special case: globalConfig handles validation before
            // invoking this mutation, since it relies on internal state to validate the
            // paths being set.
            return;
          }

        default:
          throw (0, _error_utils.spawnUnknownSwitchCaseError)('mutation type', mutation, 'type');
      }
    }
    /** @internal */

  }, {
    key: "_applyOptimisticUpdatesForMutation",
    value: function _applyOptimisticUpdatesForMutation(mutation) {
      // GlobalConfig updates are different to other mutations (on models): for models, we
      // only apply optimistic updates if the relevant models are loaded, whereas for
      // SET_MULTIPLE_GLOBAL_CONFIG_PATHS we always apply optimistic updates.
      if (mutation.type === _mutations.MutationTypes.SET_MULTIPLE_GLOBAL_CONFIG_PATHS) {
        this._applyGlobalConfigUpdates(mutation.updates);

        return true;
      }

      var modelChanges = this._getOptimisticModelChangesForMutation(mutation);

      if (modelChanges.length > 0) {
        this._applyModelChanges(modelChanges);

        return true;
      }

      return false;
    }
    /** @internal */

  }, {
    key: "_getOptimisticModelChangesForMutation",
    value: function _getOptimisticModelChangesForMutation(mutation) {
      switch (mutation.type) {
        case _mutations.MutationTypes.SET_MULTIPLE_RECORDS_CELL_VALUES:
          {
            var tableId = mutation.tableId,
                records = mutation.records;

            var recordStore = this._base.__getRecordStore(tableId);

            return records.flatMap(record => Object.keys(record.cellValuesByFieldId).filter(fieldId => recordStore.areCellValuesLoadedForFieldId(fieldId)).map(fieldId => ({
              path: ['tablesById', tableId, 'recordsById', record.id, 'cellValuesByFieldId', fieldId],
              value: record.cellValuesByFieldId[fieldId]
            })));
          }

        case _mutations.MutationTypes.DELETE_MULTIPLE_RECORDS:
          {
            var _tableId3 = mutation.tableId,
                recordIds = mutation.recordIds;

            var _recordStore2 = this._base.__getRecordStore(_tableId3);

            if (!_recordStore2.isRecordMetadataLoaded) {
              return [];
            }

            return [...recordIds.map(recordId => ({
              path: ['tablesById', _tableId3, 'recordsById', recordId],
              value: undefined
            })), ...this._base.getTableById(_tableId3).views.flatMap(view => {
              var viewDataStore = _recordStore2.getViewDataStore(view.id);

              if (!viewDataStore.isDataLoaded) {
                return [];
              }

              return viewDataStore.__generateChangesForParentTableDeleteMultipleRecords(recordIds);
            })];
          }

        case _mutations.MutationTypes.CREATE_MULTIPLE_RECORDS:
          {
            var _tableId4 = mutation.tableId,
                _records2 = mutation.records;

            var _recordStore3 = this._base.__getRecordStore(_tableId4);

            if (!_recordStore3.isRecordMetadataLoaded) {
              return [];
            }

            return [..._records2.map(record => {
              // Only apply optimistic changes for fields that are loaded
              var filteredCellValuesByFieldId = {};
              var _iteratorNormalCompletion4 = true;
              var _didIteratorError4 = false;
              var _iteratorError4 = undefined;

              try {
                for (var _iterator4 = (0, _private_utils.entries)(record.cellValuesByFieldId)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                  var _step4$value = (0, _slicedToArray2.default)(_step4.value, 2),
                      fieldId = _step4$value[0],
                      cellValue = _step4$value[1];

                  if (_recordStore3.areCellValuesLoadedForFieldId(fieldId)) {
                    filteredCellValuesByFieldId[fieldId] = cellValue;
                  }
                }
              } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
                    _iterator4.return();
                  }
                } finally {
                  if (_didIteratorError4) {
                    throw _iteratorError4;
                  }
                }
              }

              return {
                path: ['tablesById', _tableId4, 'recordsById', record.id],
                value: {
                  id: record.id,
                  cellValuesByFieldId: filteredCellValuesByFieldId,
                  commentCount: 0,
                  createdTime: new Date().toJSON()
                }
              };
            }), ...this._base.getTableById(_tableId4).views.flatMap(view => {
              var viewDataStore = _recordStore3.getViewDataStore(view.id);

              if (!viewDataStore.isDataLoaded) {
                return [];
              }

              return viewDataStore.__generateChangesForParentTableAddMultipleRecords(_records2.map(record => record.id));
            })];
          }

        case _mutations.MutationTypes.SET_MULTIPLE_GLOBAL_CONFIG_PATHS:
          {
            throw (0, _error_utils.spawnError)('attempting to generate model updates for SET_MULTIPLE_GLOBAL_CONFIG_PATH');
          }

        default:
          throw (0, _error_utils.spawnUnknownSwitchCaseError)('mutation type', mutation, 'type');
      }
    }
  }]);
  return Mutations;
}();

var _default = Mutations;
exports.default = _default;