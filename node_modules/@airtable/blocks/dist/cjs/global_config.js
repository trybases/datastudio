"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.map");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

require("regenerator-runtime/runtime");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _watchable = _interopRequireDefault(require("./watchable"));

var _get_sdk = _interopRequireDefault(require("./get_sdk"));

var _error_utils = require("./error_utils");

var _mutations = require("./types/mutations");

var _private_utils = require("./private_utils");

/** @module @airtable/blocks: globalConfig */

/** */
// NOTE: GlobalConfig is essentially a wrapper around a generic key-value store.
// It's called GlobalConfig in order to convey two main points about its intended
// usage:
// 1) that it is synced 'globally' across clients (at some point we might make
//    a UserConfig which would be scoped to an individual user), and
// 2) that is should be used mainly for configuration of the block (kv store
//    as a name seems a bit too vague in terms of intended usage).

/**
 * A key-value store for persisting configuration options for a block installation.
 *
 * The contents will be synced in real-time to all logged-in users of the installation.
 * Contents will not be updated in real-time when the installation is running in
 * a publicly shared base.
 *
 * Any key can be watched to know when the value of the key changes. If you want your
 * component to automatically re-render whenever any key on GlobalConfig changes, try using the
 * {@link useGlobalConfig} hook.
 *
 * You should not need to construct this object yourself.
 *
 * The maximum allowed size of each URL-encoded write to GlobalConfig is 100kB.
 *
 * @example
 * ```js
 * import {globalConfig} from '@airtable/blocks';
 * ```
 * @docsPath models/GlobalConfig
 */
var GlobalConfig =
/*#__PURE__*/
function (_Watchable) {
  (0, _inherits2.default)(GlobalConfig, _Watchable);
  (0, _createClass2.default)(GlobalConfig, null, [{
    key: "_isWatchableKey",

    /** @internal */

    /** @internal */
    value: function _isWatchableKey(key) {
      // The user can store any arbitrary key in the global config, so there's
      // not much we can do here to check if a key is valid.
      return true;
    }
    /** @internal */

  }]);

  /**
   * @internal
   */
  function GlobalConfig(initialKvValuesByKey, airtableInterface) {
    var _this;

    (0, _classCallCheck2.default)(this, GlobalConfig);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(GlobalConfig).call(this));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_kvStore", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_airtableInterface", void 0);
    _this._kvStore = initialKvValuesByKey;
    _this._airtableInterface = airtableInterface;
    return _this;
  }
  /**
   * @internal
   */


  (0, _createClass2.default)(GlobalConfig, [{
    key: "__getTopLevelKey",
    value: function __getTopLevelKey(key) {
      if (Array.isArray(key)) {
        return key[0];
      }

      return key;
    }
    /**
     * @internal
     */

  }, {
    key: "_formatKeyAsPath",
    value: function _formatKeyAsPath(key) {
      if (!Array.isArray(key)) {
        return [key];
      }

      return key;
    }
    /**
     * @internal
     */

  }, {
    key: "_validatePath",
    value: function _validatePath(path, store) {
      var validation = this._airtableInterface.globalConfigHelpers.validatePath(path, store);

      if (!validation.isValid) {
        return validation;
      }

      if (path[0] === '*') {
        return {
          isValid: false,
          reason: "cannot use '*' as a top-level key"
        };
      }

      return {
        isValid: true
      };
    }
    /**
     * Get the value at a path. Throws an error if the path is invalid.
     *
     * Returns undefined if no value exists at that path.
     *
     * @param key A string for the top-level key, or an array of strings describing the path to the value.
     * @example
     * ```js
     * import {globalConfig} from '@airtable/blocks';
     *
     * const topLevelValue = globalConfig.get('topLevelKey');
     * const nestedValue = globalConfig.get(['topLevelKey', 'nested', 'deeply']);
     * ```
     */

  }, {
    key: "get",
    value: function get(key) {
      var path = this._formatKeyAsPath(key);

      var pathValidationResult = this._validatePath(path, this._kvStore);

      if (!pathValidationResult.isValid) {
        throw (0, _error_utils.spawnError)('Invalid globalConfig path: %s', pathValidationResult.reason);
      }

      var value = (0, _private_utils.getValueAtOwnPath)(this._kvStore, path); // value is returned as `unknown` from getValueAtOwnPath, but we know it must be a `GlobalConfigValue | void`

      return value;
    }
    /**
     * Checks whether the current user has permission to set the given global config key.
     *
     * Accepts partial input, in the same format as {@link setAsync}.
     * The more information provided, the more accurate the permissions check will be.
     *
     * Returns `{hasPermission: true}` if the current user can set the specified key,
     * `{hasPermission: false, reasonDisplayString: string}` otherwise.  `reasonDisplayString` may
     * be used to display an error message to the user.
     *
     * @param key A string for the top-level key, or an array of strings describing the path to set.
     * @param value The value to set at the specified path. Use `undefined` to delete the value at the given path.
     *
     * @example
     * ```js
     * // Check if user can update a specific key and value.
     * const setCheckResult =
     *     globalConfig.checkPermissionsForSet('favoriteColor', 'purple');
     * if (!setCheckResult.hasPermission) {
     *     alert(setCheckResult.reasonDisplayString);
     * }
     *
     * // Check if user can update a specific key without knowing the value
     * const setKeyCheckResult =
     *     globalConfig.checkPermissionsForSet('favoriteColor');
     *
     * // Check if user can update globalConfig without knowing key or value
     * const setUnknownKeyCheckResult = globalConfig.checkPermissionsForSet();
     * ```
     */

  }, {
    key: "checkPermissionsForSet",
    value: function checkPermissionsForSet(key, value) {
      return this.checkPermissionsForSetPaths([{
        path: key ? this._formatKeyAsPath(key) : undefined,
        value
      }]);
    }
    /**
     * An alias for `globalConfig.checkPermissionsForSet(key, value).hasPermission`.
     *
     * Checks whether the current user has permission to set the given global config key.
     *
     * Accepts partial input, in the same format as {@link setAsync}.
     * The more information provided, the more accurate the permissions check will be.
     *
     * @param key A string for the top-level key, or an array of strings describing the path to set.
     * @param value The value to set at the specified path. Use `undefined` to delete the value at the given path.
     *
     * @example
     * ```js
     * // Check if user can update a specific key and value.
     * const canSetFavoriteColorToPurple =
     *     globalConfig.hasPermissionToSet('favoriteColor', 'purple');
     * if (!canSetFavoriteColorToPurple) {
     *     alert('Not allowed!');
     * }
     *
     * // Check if user can update a specific key without knowing the value
     * const canSetFavoriteColor = globalConfig.hasPermissionToSet('favoriteColor');
     *
     * // Check if user can update globalConfig without knowing key or value
     * const canSetGlobalConfig = globalConfig.hasPermissionToSet();
     * ```
     */

  }, {
    key: "hasPermissionToSet",
    value: function hasPermissionToSet(key, value) {
      return this.checkPermissionsForSet(key, value).hasPermission;
    }
    /**
     * Sets a value at a path. Throws an error if the path or value is invalid.
     *
     * This action is asynchronous: `await` the returned promise if you wish to wait for the
     * update to be persisted to Airtable servers.
     *
     * Updates are applied optimistically locally, so your change will be reflected in
     * {@link GlobalConfig} before the promise resolves.
     *
     * @param key A string for the top-level key, or an array of strings describing the path to set.
     * @param value The value to set at the specified path. Use `undefined` to delete the value at the given path.
     * @example
     * ```js
     * import {globalConfig} from '@airtable/blocks';
     *
     * function updateFavoriteColorIfPossible(color) {
     *     if (globalConfig.hasPermissionToSetPaths('favoriteColor', color)) {
     *         globalConfig.setPathsAsync('favoriteColor', color);
     *     }
     *     // The update is now applied within your block (eg will be
     *     // reflected in globalConfig) but are still being saved to
     *     // Airtable servers (e.g. may not be updated for other users yet)
     * }
     *
     * async function updateFavoriteColorIfPossibleAsync(color) {
     *     if (globalConfig.hasPermissionToSet('favoriteColor', color)) {
     *         await globalConfig.setAsync('favoriteColor', color);
     *     }
     *     // globalConfig updates have been saved to Airtable servers.
     *     alert('favoriteColor has been updated');
     * }
     * ```
     */

  }, {
    key: "setAsync",
    value: function setAsync(key, value) {
      var path;
      return _regenerator.default.async(function setAsync$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              path = this._formatKeyAsPath(key);
              _context.next = 3;
              return _regenerator.default.awrap(this.setPathsAsync([{
                path,
                value
              }]));

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
    /**
     * Checks whether the current user has permission to perform the specified updates to global config.
     *
     * Accepts partial input, in the same format as {@link setPathsAsync}.
     * The more information provided, the more accurate the permissions check will be.
     *
     * Returns `{hasPermission: true}` if the current user can set the specified key,
     * `{hasPermission: false, reasonDisplayString: string}` otherwise. `reasonDisplayString` may be
     * used to display an error message to the user.
     *
     * @param updates The paths and values to set.
     * @example
     * ```js
     * // Check if user can update a specific keys and values.
     * const setPathsCheckResult = globalConfig.checkPermissionsForSet([
     *     {path: ['topLevelKey1', 'nestedKey1'], value: 'foo'},
     *     {path: ['topLevelKey2', 'nestedKey2'], value: 'bar'},
     * ]);
     * if (!setPathsCheckResult.hasPermission) {
     *     alert(setPathsCheckResult.reasonDisplayString);
     * }
     *
     * // Check if user could potentially set globalConfig values.
     * // Equivalent to globalConfig.checkPermissionsForSet()
     * const setUnknownPathsCheckResult =
     *     globalConfig.checkPermissionsForSetPaths();
     * ```
     */

  }, {
    key: "checkPermissionsForSetPaths",
    value: function checkPermissionsForSetPaths(updates) {
      return (0, _get_sdk.default)().__mutations.checkPermissionsForMutation({
        type: _mutations.MutationTypes.SET_MULTIPLE_GLOBAL_CONFIG_PATHS,
        updates: updates ? updates.map((_ref) => {
          var path = _ref.path,
              value = _ref.value;
          return {
            path: path || undefined,
            value
          };
        }) : undefined
      });
    }
    /**
     * An alias for `globalConfig.checkPermissionsForSetPaths(updates).hasPermission`.
     *
     * Checks whether the current user has permission to perform the specified updates to global
     * config.
     *
     * Accepts partial input, in the same format as {@link setPathsAsync}.
     * The more information provided, the more accurate the permissions check will be.
     *
     * @param updates The paths and values to set.
     *
     * @example
     * ```js
     * // Check if user can update a specific keys and values.
     * const canSetPaths = globalConfig.hasPermissionToSetPaths([
     *     {path: ['topLevelKey1', 'nestedKey1'], value: 'foo'},
     *     {path: ['topLevelKey2', 'nestedKey2'], value: 'bar'},
     * ]);
     * if (!canSetPaths) {
     *     alert('not allowed!');
     * }
     *
     * // Check if user could potentially set globalConfig values.
     * // Equivalent to globalConfig.hasPermissionToSet()
     * const canSetAnyPaths = globalConfig.hasPermissionToSetPaths();
     * ```
     */

  }, {
    key: "hasPermissionToSetPaths",
    value: function hasPermissionToSetPaths(updates) {
      return this.checkPermissionsForSetPaths(updates).hasPermission;
    }
    /**
     * Sets multiple values. Throws if any path or value is invalid.
     *
     * This action is asynchronous: `await` the returned promise if you wish to wait for the
     * updates to be persisted to Airtable servers.
     * Updates are applied optimistically locally, so your changes will be reflected in
     * {@link GlobalConfig} before the promise resolves.
     *
     * @param updates The paths and values to set.
     * @example
     * ```js
     * import {globalConfig} from '@airtable/blocks';
     *
     * const updates = [
     *     {path: ['topLevelKey1', 'nestedKey1'], value: 'foo'},
     *     {path: ['topLevelKey2', 'nestedKey2'], value: 'bar'},
     * ];
     *
     * function applyUpdatesIfPossible() {
     *     if (globalConfig.hasPermissionToSetPaths(updates)) {
     *         globalConfig.setPathsAsync(updates);
     *     }
     *     // The updates are now applied within your block (eg will be reflected in
     *     // globalConfig) but are still being saved to Airtable servers (e.g. they
     *     // may not be updated for other users yet)
     * }
     *
     * async function applyUpdatesIfPossibleAsync() {
     *     if (globalConfig.hasPermissionToSetPaths(updates)) {
     *         await globalConfig.setPathsAsync(updates);
     *     }
     *     // globalConfig updates have been saved to Airtable servers.
     *     alert('globalConfig has been updated');
     * }
     * ```
     */

  }, {
    key: "setPathsAsync",
    value: function setPathsAsync(updates) {
      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, update, pathValidation;

      return _regenerator.default.async(function setPathsAsync$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (this.hasPermissionToSetPaths(updates)) {
                _context2.next = 2;
                break;
              }

              throw (0, _error_utils.spawnError)('Your permission level does not allow setting globalConfig values');

            case 2:
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _iteratorError = undefined;
              _context2.prev = 5;
              _iterator = updates[Symbol.iterator]();

            case 7:
              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                _context2.next = 15;
                break;
              }

              update = _step.value;
              pathValidation = this._validatePath(update.path, this._kvStore);

              if (pathValidation.isValid) {
                _context2.next = 12;
                break;
              }

              throw (0, _error_utils.spawnError)('Invalid globalConfig path: %s', pathValidation.reason);

            case 12:
              _iteratorNormalCompletion = true;
              _context2.next = 7;
              break;

            case 15:
              _context2.next = 21;
              break;

            case 17:
              _context2.prev = 17;
              _context2.t0 = _context2["catch"](5);
              _didIteratorError = true;
              _iteratorError = _context2.t0;

            case 21:
              _context2.prev = 21;
              _context2.prev = 22;

              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }

            case 24:
              _context2.prev = 24;

              if (!_didIteratorError) {
                _context2.next = 27;
                break;
              }

              throw _iteratorError;

            case 27:
              return _context2.finish(24);

            case 28:
              return _context2.finish(21);

            case 29:
              _context2.next = 31;
              return _regenerator.default.awrap((0, _get_sdk.default)().__mutations.applyMutationAsync({
                type: _mutations.MutationTypes.SET_MULTIPLE_GLOBAL_CONFIG_PATHS,
                updates
              }));

            case 31:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this, [[5, 17, 21, 29], [22,, 24, 28]]);
    }
    /**
     * @internal
     * this shouldn't be called directly - instead, use getSdk().__applyGlobalConfigUpdates()
     */

  }, {
    key: "__setMultipleKvPaths",
    value: function __setMultipleKvPaths(updates) {
      // This helper validates updates and throw errors if necessary.
      // To avoid the case where an error is encountered after some updates have already been
      // applied (where we'd have to crash the block instead of letting the developer catch the
      // error), it doesn't mutate the current store: it returns newKvStore with changes applied.
      var _this$_airtableInterf = this._airtableInterface.globalConfigHelpers.validateAndApplyUpdates(updates, this._kvStore),
          newKvStore = _this$_airtableInterf.newKvStore,
          changedTopLevelKeys = _this$_airtableInterf.changedTopLevelKeys; // The updates are all good! Replace our kvStore with the new version.


      this._kvStore = newKvStore; // Now loop over the top level keys to fire change events.

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = changedTopLevelKeys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var key = _step2.value;

          this._onChange(key);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      if (changedTopLevelKeys.length) {
        this._onChange('*');
      }
    }
  }]);
  return GlobalConfig;
}(_watchable.default);

(0, _defineProperty2.default)(GlobalConfig, "_className", 'GlobalConfig');
var _default = GlobalConfig;
exports.default = _default;