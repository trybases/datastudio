"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.get-own-property-descriptors");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.set");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = withStyledSystem;
exports.splitStyleProps = splitStyleProps;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var React = _interopRequireWildcard(require("react"));

var _emotion = require("emotion");

var _hoistNonReactStatics = _interopRequireDefault(require("hoist-non-react-statics"));

var _private_utils = require("../private_utils");

var _use_styled_system = _interopRequireDefault(require("./use_styled_system"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * @internal
 * A higher-order component for working with the `useStyledSystem` hook in class-based components.
 * It takes a React component and converts style props into a single className prop.
 *
 * Generate boilerplate for using this hook with our scaffolding tool: https://o80pm.csb.app/
 *
 * Returns The transformed React component.
 *
 * @param Component The React component you want to use with styled system.
 * @param styleParser The style parser, constructed with `compose`.
 * @example
 * ```js
 * import * as React from 'react';
 * import {compose} from '@styled-system/core';
 * import withStyledSystem from './with_styled_system';
 * import {
 *     flexContainerSet,
 *     flexContainerSetPropTypes,
 *     FlexContainerSetProps,
 *     flexItemSet,
 *     FlexItemSetProps,
 *     flexItemSetPropTypes,
 *     margin,
 *     marginPropTypes,
 *     MarginProps,
 * } from './system';
 *
 * interface Props {
 *     className?: string;
 *     onClick: () => void;
 *     children: React.ReactNode;
 * };
 *
 * interface MyComponentStyleProps extends FlexContainerSetProps, FlexItemSetProps, MarginProps {}
 *
 * const styleParser = compose(
 *     flexContainerSet,
 *     flexItemSet,
 *     margin,
 * );
 *
 * const myComponentStylePropTypes = {
 *     ...flexContainerSetPropTypes,
 *     ...flexItemSetPropTypes,
 *     ...marginPropTypes,
 * };
 *
 * class MyComponent extends React.Component<Props, void> {
 *     static staticProp = 'STATIC';
 *     render() {
 *         const {className, onClick, children} = this.props;
 *         return (
 *             <div className={className} onClick={onClick}>
 *                 {children}
 *             </div>
 *         );
 *     }
 * }
 *
 * export default withStyledSystem<Props, MyComponentStyleProps, MyComponent, { staticProp: string }>(
 *     MyComponent,
 *     styleParser,
 *     myComponentStylePropTypes,
 *     {
 *         // Optional default style props.
 *         margin: 3
 *     }
 * );
 * ```
 */
function withStyledSystem(Component, styleParser, stylePropTypes, defaultStyleProps) {
  var WithStyledSystem = React.forwardRef((props, ref) => {
    var _splitStyleProps = splitStyleProps(props, styleParser.propNames, defaultStyleProps),
        styleProps = _splitStyleProps.styleProps,
        nonStyleProps = _splitStyleProps.nonStyleProps;

    var classNameForStyleProps = (0, _use_styled_system.default)((0, _private_utils.cast)(styleProps), styleParser);
    return React.createElement(Component, (0, _extends2.default)({
      ref: ref
    }, nonStyleProps, {
      className: (0, _emotion.cx)(classNameForStyleProps, nonStyleProps.className)
    }));
  });
  WithStyledSystem.propTypes = _objectSpread({}, Component.propTypes, {}, stylePropTypes);
  var componentName = Component.displayName || Component.name || 'Component';
  WithStyledSystem.displayName = "WithStyledSystem(".concat(componentName, ")");
  (0, _hoistNonReactStatics.default)(WithStyledSystem, Component);
  return WithStyledSystem;
}
/**
 * @internal
 * A helper method to split props into style props (for use with styled system) and
 * non-style props (to be passed into the wrapped component).
 *
 * Returns A result object with two keys: `styleProps` and `nonStyleProps`, which contain the
 * respective split props.
 *
 * @param props Props to be split into style and non-style props.
 * @param stylePropNames The list of allowed style prop names.
 * @param defaultStyleProps Default values for style props.
 */


function splitStyleProps(props) {
  var stylePropNames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var defaultStyleProps = arguments.length > 2 ? arguments[2] : undefined;
  var stylePropNamesSet = new Set(stylePropNames);
  var styleProps = _objectSpread({}, defaultStyleProps) || {};
  var nonStyleProps = {};
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _private_utils.keys)(props)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var propName = _step.value;

      if (stylePropNamesSet.has(propName)) {
        styleProps[propName] = props[propName];
      } else {
        nonStyleProps[propName] = props[propName];
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return {
    styleProps,
    nonStyleProps
  };
}