"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var React = _interopRequireWildcard(require("react"));

var _get_sdk = _interopRequireDefault(require("../get_sdk"));

/**
 * @module @airtable/blocks/ui: ViewportConstraint
 * @docsPath UI/components/ViewportConstraint
 */

/** */
var didSizeChange = (prev, next) => (prev && prev.width) !== (next && next.width) || (prev && prev.height) !== (next && next.height);
/**
 * When mounted, this wrapper component applies size constraints to the {@link Viewport}.
 * Like {@link addMinSize}, this will fullscreen the block if necessary and possible when
 * `minSize` is updated.
 *
 * @example
 * ```js
 * import {ViewportConstraint} from '@airtable/blocks/ui';
 * <ViewportConstraint minSize={{width: 400}} />
 * ```
 *
 * @example
 * ```js
 * import {ViewportConstraint} from '@airtable/blocks/ui';
 * <ViewportConstraint maxFullScreenSize={{width: 600, height: 400}}>
 *      <div>I need a max fullscreen size!</div>
 * </ViewportConstraint>
 * ```
 * @docsPath UI/components/ViewportConstraint
 * @component
 */


var ViewportConstraint =
/*#__PURE__*/
function (_React$Component) {
  (0, _inherits2.default)(ViewportConstraint, _React$Component);

  function ViewportConstraint() {
    var _this;

    (0, _classCallCheck2.default)(this, ViewportConstraint);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ViewportConstraint).call(this, ...args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_removeMinSizeConstraintFn", null);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_removeMaxFullscreenSizeConstrainFn", null);
    return _this;
  }

  (0, _createClass2.default)(ViewportConstraint, [{
    key: "componentDidMount",

    /** @hidden */
    value: function componentDidMount() {
      this._setMinSizeConstraint();

      this._setMaxFullscreenSizeConstraint();
    }
    /** @hidden */

  }, {
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps) {
      return this.props.children !== nextProps.children || didSizeChange(this.props.minSize, nextProps.minSize) || didSizeChange(this.props.maxFullscreenSize, nextProps.maxFullscreenSize);
    }
    /** @hidden */

  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (didSizeChange(prevProps.minSize, this.props.minSize)) {
        this._setMinSizeConstraint();
      }

      if (didSizeChange(prevProps.maxFullscreenSize, this.props.maxFullscreenSize)) {
        this._setMaxFullscreenSizeConstraint();
      }
    }
    /** @hidden */

  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this._removeMinSizeConstraint();

      this._removeMaxFullscreenSizeConstraint();
    }
    /** @internal */

  }, {
    key: "_removeMinSizeConstraint",
    value: function _removeMinSizeConstraint() {
      if (this._removeMinSizeConstraintFn) {
        this._removeMinSizeConstraintFn();

        this._removeMinSizeConstraintFn = null;
      }
    }
    /** @internal */

  }, {
    key: "_removeMaxFullscreenSizeConstraint",
    value: function _removeMaxFullscreenSizeConstraint() {
      if (this._removeMaxFullscreenSizeConstrainFn) {
        this._removeMaxFullscreenSizeConstrainFn();

        this._removeMaxFullscreenSizeConstrainFn = null;
      }
    }
    /** @internal */

  }, {
    key: "_setMinSizeConstraint",
    value: function _setMinSizeConstraint() {
      this._removeMinSizeConstraint();

      var minSize = this.props.minSize;

      if (minSize) {
        this._removeMinSizeConstraintFn = (0, _get_sdk.default)().viewport.addMinSize(minSize);
      }
    }
    /** @internal */

  }, {
    key: "_setMaxFullscreenSizeConstraint",
    value: function _setMaxFullscreenSizeConstraint() {
      this._removeMaxFullscreenSizeConstraint();

      var maxFullscreenSize = this.props.maxFullscreenSize;

      if (maxFullscreenSize) {
        this._removeMaxFullscreenSizeConstrainFn = (0, _get_sdk.default)().viewport.addMaxFullscreenSize(maxFullscreenSize);
      }
    }
    /** @hidden */

  }, {
    key: "render",
    value: function render() {
      return React.createElement(React.Fragment, null, this.props.children);
    }
  }]);
  return ViewportConstraint;
}(React.Component);

(0, _defineProperty2.default)(ViewportConstraint, "propTypes", {
  minSize: _propTypes.default.shape({
    width: _propTypes.default.number,
    height: _propTypes.default.number
  }),
  maxFullscreenSize: _propTypes.default.shape({
    width: _propTypes.default.number,
    height: _propTypes.default.number
  }),
  children: _propTypes.default.node
});
var _default = ViewportConstraint;
exports.default = _default;