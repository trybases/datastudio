"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _watchable = _interopRequireDefault(require("./watchable"));

var _private_utils = require("./private_utils");

/** @module @airtable/blocks: settingsButton */

/** */
var WatchableSettingsButtonKeys = Object.freeze({
  isVisible: 'isVisible',
  click: 'click'
});
/**
 * A watchable key in {@link SettingsButton}.
 * - `isVisible`
 * - `click`
 */

/**
 * Interface to the settings button that lives outside the block's viewport.
 *
 * The {@link useSettingsButton} hook is the recommended way to use the settings button, but you can
 * also use it with {@link useWatchable} if you want more granular control (for example, to only
 * show the button conditionally).
 *
 * @alias settingsButton
 * @example
 * ```js
 * import {settingsButton} from '@airtable/blocks';
 * import {useWatchable} from '@airtable/blocks/ui';
 *
 * function BlockWithSettings({shouldShowSettingsButton}) {
 *     useEffect(() => {
 *         // A count of calls to `show()` and `hide()` is maintained internally. The button will
 *         // stay visible if there are more calls to `show()` than `hide()` - so here, we check
 *         // `isVisible` so we only we only call them when necessary.
 *         // The button is not visible by default.
 *         if (shouldShowSettingsButton && !settingsButton.isVisible) {
 *             settingsButton.show();
 *         } else if (!shouldShowSettingsButton && settingsButton.isVisible) {
 *             settingsButton.hide();
 *         }
 *     });
 *
 *     useWatchable(settingsButton, 'click', function() {
 *         alert('Clicked!');
 *     });
 * }
 * ```
 * @docsPath models/SettingsButton
 */
var SettingsButton =
/*#__PURE__*/
function (_Watchable) {
  (0, _inherits2.default)(SettingsButton, _Watchable);
  (0, _createClass2.default)(SettingsButton, null, [{
    key: "_isWatchableKey",

    /** @internal */

    /** @internal */
    value: function _isWatchableKey(key) {
      return (0, _private_utils.isEnumValue)(WatchableSettingsButtonKeys, key);
    }
    /** @internal */

  }]);

  /** @internal */
  function SettingsButton(airtableInterface) {
    var _this;

    (0, _classCallCheck2.default)(this, SettingsButton);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(SettingsButton).call(this));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_refCount", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_airtableInterface", void 0);
    _this._refCount = 0;
    _this._airtableInterface = airtableInterface;
    return _this;
  }
  /**
   * Whether the settings button is being shown.
   * Can be watched.
   */


  (0, _createClass2.default)(SettingsButton, [{
    key: "show",

    /**
     * Show the settings button.
     */
    value: function show() {
      // Is now visible: trigger change watches and set it to be visible
      if (this._refCount === 0) {
        this._onChange(WatchableSettingsButtonKeys.isVisible, true);

        this._airtableInterface.setSettingsButtonVisibility(true);
      }

      this._refCount += 1;
    }
    /**
     * Hide the settings button.
     *
     * Note: A count of calls to `show()` and `hide()` is maintained internally. The button will
     * stay visible if there are more calls to `show()` than `hide()`.
     */

  }, {
    key: "hide",
    value: function hide() {
      // Be forgiving if hide() is called too many times, since we don't expose the count
      if (this._refCount > 0) {
        this._refCount -= 1;
      } // Should no longer be visible: trigger change watches and set it to be not visible


      if (this._refCount === 0) {
        this._onChange(WatchableSettingsButtonKeys.isVisible, false);

        this._airtableInterface.setSettingsButtonVisibility(false);
      }
    }
    /** @internal */

  }, {
    key: "__onClick",
    value: function __onClick() {
      this._onChange(WatchableSettingsButtonKeys.click);
    }
  }, {
    key: "isVisible",
    get: function get() {
      return this._refCount > 0;
    }
  }]);
  return SettingsButton;
}(_watchable.default);

(0, _defineProperty2.default)(SettingsButton, "_className", 'SettingsButton');
var _default = SettingsButton;
exports.default = _default;