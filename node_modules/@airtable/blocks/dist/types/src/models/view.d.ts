import { ViewData, ViewType } from '../types/view';
import { ObjectValues } from '../private_utils';
import AbstractModel from './abstract_model';
import { RecordQueryResultOpts } from './record_query_result';
import TableOrViewQueryResult from './table_or_view_query_result';
import ViewMetadataQueryResult from './view_metadata_query_result';
declare const WatchableViewKeys: Readonly<{
    name: "name";
}>;
/**
 * A key in {@link View} that can be watched.
 * - `name`
 */
export declare type WatchableViewKey = ObjectValues<typeof WatchableViewKeys>;
/**
 * A class that represents an Airtable view. Every {@link Table} has one or more views.
 *
 * @docsPath models/View
 */
declare class View extends AbstractModel<ViewData, WatchableViewKey> {
    /**
     * The name of the view. Can be watched.
     *
     * @example
     * ```js
     * console.log(myView.name);
     * // => 'Grid view'
     * ```
     */
    get name(): string;
    /**
     * The type of the view, such as Grid, Calendar, or Kanban. Should never change because view types cannot be modified.
     *
     * @example
     * ```js
     * console.log(myView.type);
     * // => 'kanban'
     * ```
     */
    get type(): ViewType;
    /**
     * The URL for the view. You can visit this URL in the browser to be taken to the view in the Airtable UI.
     *
     * @example
     * ```js
     * console.log(myView.url);
     * // => 'https://airtable.com/tblxxxxxxxxxxxxxx/viwxxxxxxxxxxxxxx'
     * ```
     */
    get url(): string;
    /**
     * Select records from the view. Returns a {@link RecordQueryResult}.
     *
     * Consider using {@link useRecords} or {@link useRecordIds} instead, unless you need the
     * features of a QueryResult (e.g. `queryResult.getRecordById`). Record hooks handle
     * loading/unloading and updating your UI automatically, but manually `select`ing records is
     * useful for one-off data processing.
     *
     * @param opts Options for the query, such as sorts, fields, and record coloring. By
     * default, records will be coloured according to the view.
     * @example
     * ```js
     * import {useBase, useRecords} from '@airtable/blocks/UI';
     * import React from 'react';
     *
     * function TodoList() {
     *     const base = useBase();
     *     const table = base.getTableByName('Tasks');
     *     const view = table.getViewByName('Grid view');
     *
     *     const queryResult = view.selectRecords();
     *     const records = useRecords(queryResult);
     *
     *     return (
     *         <ul>
     *             {records.map(record => (
     *                 <li key={record.id}>
     *                     {record.name || 'Unnamed record'}
     *                 </li>
     *             ))}
     *         </ul>
     *     );
     * }
     * ```
     */
    selectRecords(opts?: RecordQueryResultOpts): TableOrViewQueryResult;
    /**
     * Select and load records from the view. Returns a {@link RecordQueryResult} promise where
     * record data has been loaded.
     *
     * Consider using {@link useRecords} or {@link useRecordIds} instead, unless you need the
     * features of a QueryResult (e.g. `queryResult.getRecordById`). Record hooks handle
     * loading/unloading and updating your UI automatically, but manually `select`ing records is
     * useful for one-off data processing.
     *
     * Once you've finished with your query, remember to call `queryResult.unloadData()`.
     *
     * @param opts Options for the query, such as sorts, fields, and record coloring. By
     * default, records will be coloured according to the view.
     * @example
     * ```js
     * async function getRecordCountAsync(view) {
     *     const query = await view.selectRecordsAsync();
     *     const recordCount = query.recordIds.length;
     *     query.unloadData();
     *     return recordCount;
     * }
     * ```
     */
    selectRecordsAsync(opts?: RecordQueryResultOpts): Promise<TableOrViewQueryResult>;
    /**
     * Select the field order and visible fields from the view. Returns a
     * {@link ViewMetadataQueryResult}.
     *
     * Consider using {@link useViewMetadata} instead if you're creating a React UI. The
     * {@link useViewMetadata} hook handles loading/unloading and updating your UI automatically,
     * but manually `select`ing data is useful for one-off data processing.
     *
     * @example
     * ```js
     * async function loadMetadataForViewAsync(view) {
     *     const viewMetadata = view.selectMetadata();
     *     await viewMetadata.loadDataAsync();
     *
     *     console.log('Visible fields:');
     *     console.log(viewMetadata.visibleFields.map(field => field.name));
     *     // => ['Field 1', 'Field 2', 'Field 3']
     *
     *     console.log('All fields:');
     *     console.log(viewMetadata.allFields.map(field => field.name));
     *     // => ['Field 1', 'Field 2', 'Field 3', 'Hidden field 4']
     *
     *     viewMetadata.unloadData();
     * }
     * ```
     */
    selectMetadata(): ViewMetadataQueryResult;
    /**
     * Select and load the field order and visible fields from the view. Returns a
     * {@link ViewMetadataQueryResult} promise where the metadata has already been loaded.
     *
     * Consider using {@link useViewMetadata} instead if you're creating a React UI. The
     * {@link useViewMetadata} hook handles loading/unloading and updating your UI automatically,
     * but manually `select`ing data is useful for one-off data processing.
     *
     * @example
     * ```js
     * async function loadMetadataForViewAsync(view) {
     *     const viewMetadata = await view.selectMetadata();
     *
     *     console.log('Visible fields:');
     *     console.log(viewMetadata.visibleFields.map(field => field.name));
     *     // => ['Field 1', 'Field 2', 'Field 3']
     *
     *     console.log('All fields:');
     *     console.log(viewMetadata.allFields.map(field => field.name));
     *     // => ['Field 1', 'Field 2', 'Field 3', 'Hidden field 4']
     *
     *     viewMetadata.unloadData();
     * }
     * ```
     */
    selectMetadataAsync(): Promise<ViewMetadataQueryResult>;
}
export default View;
//# sourceMappingURL=view.d.ts.map