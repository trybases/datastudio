import { RecordId } from '../types/record';
import { TableId } from '../types/table';
import { ViewId } from '../types/view';
import { FieldId } from '../types/field';
import { ObjectValues, ObjectMap } from '../private_utils';
import AbstractModelWithAsyncData from './abstract_model_with_async_data';
import Table from './table';
import View from './view';
import Record from './record';
declare const WatchableCursorKeys: Readonly<{
    selectedRecordIds: "selectedRecordIds";
    selectedFieldIds: "selectedFieldIds";
    activeTableId: "activeTableId";
    activeViewId: "activeViewId";
    isDataLoaded: "isDataLoaded";
}>;
/**
 * Watchable keys in {@link Cursor}.
 * - `selectedRecordIds`
 * - `selectedFieldIds`
 * - `activeTableId`
 * - `activeViewId`
 * - `isDataLoaded`
 */
declare type WatchableCursorKey = ObjectValues<typeof WatchableCursorKeys>;
/** @hidden */
interface CursorData {
    selectedRecordIdSet: ObjectMap<RecordId, boolean> | null;
    selectedFieldIdSet: ObjectMap<FieldId, boolean> | null;
    activeTableId: TableId | null;
    activeViewId: ViewId | null;
}
/**
 * Model class containing information about the state of the user's current interactions in
 * Airtable - specifically, their active table, active view, selected records and selected fields.
 * Also allows you to set the active table and active view.
 *
 * Selected records and fields are not loaded by default and the cursor must be loaded with
 * {@link useLoadable} to access them.
 *
 * ```js
 * import {cursor} from '@airtable/blocks';
 * import {useWatchable} from '@airtable/blocks/ui';
 *
 *  function ActiveTableAndView() {
 *      // re-render whenever the active table or view changes
 *      useWatchable(cursor, ['activeTableId', 'activeViewId']);
 *
 *      return (
 *          <div>
 *              Active table: {cursor.activeTableId)}
 *              Active view: {cursor.activeViewId}
 *          </div>
 *      );
 *  }
 * ```
 *
 * ```js
 * import {cursor} from '@airtable/blocks';
 * import {useLoadable, useWatchable} from '@airtable/blocks/ui';
 *
 *  function SelectedRecordAndFieldIds() {
 *      // load selected records and fields
 *      useLoadable(cursor);
 *
 *      // re-render whenever the list of selected records or fields changes
 *      useWatchable(cursor, ['selectedRecordIds', 'selectedFieldIds']);
 *
 *      return (
 *          <div>
 *              Selected records: {cursor.selectedRecordIds.join(', ')}
 *              Selected fields: {cursor.selectedFieldIds.join(', ')}
 *          </div>
 *      );
 *  }
 * ```
 *
 * @docsPath models/Cursor
 */
declare class Cursor extends AbstractModelWithAsyncData<CursorData, WatchableCursorKey> {
    /**
     * The record IDs of all currently selected records, or an empty array if no records are selected.
     *
     * Not loaded by default. You must load cursor data with `useLoadable(cursor)` (recommended) or
     * `cursor.loadDataAsync()` before use.
     *
     * Can be watched.
     */
    get selectedRecordIds(): Array<RecordId>;
    /**
     * The field IDs of all currently selected fields, or an empty array if no fields are selected.
     *
     * Not loaded by default: you must load cursor data with `useLoadable(cursor)` (recommended) or
     * `cursor.loadDataAsync()` before use.
     *
     * Can be watched.
     */
    get selectedFieldIds(): Array<RecordId>;
    /**
     * Checks whether a given record is selected.
     *
     * Selected records are not loaded by default. You must load cursor data with
     * `useLoadable(cursor)` (recommended) or `cursor.loadDataAsync()` before use.
     *
     * @param recordOrRecordId The record or record ID to check for.
     */
    isRecordSelected(recordOrRecordId: Record | string): boolean;
    /**
     * The currently active table ID. Can be null when the active table has changed and is not yet
     * loaded, and can also refer to a table that is not yet loaded.
     *
     * When fetching the {@link Table}, use `base.getTableByIdIfExists(cursor.activeTableId)` and
     * check the return value is not `null` to be resilient to those cases.
     *
     * Can be watched.
     */
    get activeTableId(): TableId | null;
    /**
     * The currently active view ID. This will always be a view belonging to `activeTableId`. Can be
     * null when the active view has changed and is not yet loaded, and can also refer to a view
     * that is not yet loaded.
     *
     * When fetching the {@link View}, use `table.getViewByIdIfExists(cursor.activeViewId)` and
     * check the return value is not `null` to be resilient to those cases.
     *
     * Can be watched.
     */
    get activeViewId(): ViewId | null;
    /**
     * Sets the specified table to active in the Airtable UI. If the blocks pane is fullscreen, the
     * table will still be set as active, but the blocks pane will continue to be displayed
     * fullscreen.
     *
     * @param tableOrTableId The target table or table ID to set as active in the Airtable main page.
     */
    setActiveTable(tableOrTableId: Table | TableId): void;
    /**
     * Sets the specified view (and corresponding table) to active in the Airtable UI. If the blocks
     * pane is fullscreen, the view will still be set as active, but the blocks pane will continue
     * to be displayed fullscreen.
     *
     * @param tableOrTableId The table or table ID that the target view belongs to.
     * @param viewOrViewId The target view or view ID to set as active in the Airtable main page.
     */
    setActiveView(tableOrTableId: Table | TableId, viewOrViewId: View | ViewId): void;
}
export default Cursor;
//# sourceMappingURL=cursor.d.ts.map