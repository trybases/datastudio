/** @module @airtable/blocks/models: Abstract models */ /** */
import { BaseData } from '../types/base';
import { FlowAnyFunction, FlowAnyObject } from '../private_utils';
import AbstractModel from './abstract_model';
/**
 * Abstract superclass for all block SDK models that need to fetch async data.
 *
 * @docsPath models/advanced/AbstractModelWithAsyncData
 */
declare class AbstractModelWithAsyncData<DataType, WatchableKey extends string> extends AbstractModel<DataType, WatchableKey> {
    /** @hidden */
    constructor(baseData: BaseData, modelId: string);
    /**
     * Watching a key that needs to load data asynchronously will automatically
     * cause the data to be fetched. Once the data is available, the callback
     * will be called.
     *
     * @inheritdoc
     */
    watch(keys: WatchableKey | ReadonlyArray<WatchableKey>, callback: FlowAnyFunction, context?: FlowAnyObject | null): Array<WatchableKey>;
    /**
     * Unwatching a key that needs to load data asynchronously will automatically
     * cause the data to be released. Once the data is available, the callback
     * will be called.
     *
     * @inheritdoc
     */
    unwatch(keys: WatchableKey | ReadonlyArray<WatchableKey>, callback: FlowAnyFunction, context?: FlowAnyObject | null): Array<WatchableKey>;
    /** */
    get isDataLoaded(): boolean;
    /**
     * Will cause all the async data to be fetched and retained. Every call to
     * `loadDataAsync` should have a matching call to `unloadData`.
     *
     * Returns a Promise that will resolve once the data is loaded.
     */
    loadDataAsync(): Promise<void>;
    /** */
    unloadData(): void;
}
export default AbstractModelWithAsyncData;
//# sourceMappingURL=abstract_model_with_async_data.d.ts.map