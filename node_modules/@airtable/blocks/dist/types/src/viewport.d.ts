/** @module @airtable/blocks: viewport */ /** */
import { ViewportSizeConstraint } from './types/viewport';
import Watchable from './watchable';
import { ObjectValues, FlowAnyFunction, FlowAnyObject } from './private_utils';
declare const WatchableViewportKeys: Readonly<{
    isFullscreen: "isFullscreen";
    size: "size";
    minSize: "minSize";
    maxFullscreenSize: "maxFullscreenSize";
}>;
/**
 * Watchable keys in {@link Viewport}.
 * - `isFullscreen`
 * - `size`
 * - `minSize`
 * - `maxFullscreenSize`
 */
declare type WatchableViewportKey = ObjectValues<typeof WatchableViewportKeys>;
/** */
declare type UnsetFn = () => void;
/**
 * Information about the current viewport
 *
 * The {@link useViewport} hook is the recommend way to watch for viewport changes
 * button, but you can also use it directly.
 *
 * @example
 * ```js
 * import {viewport} from '@airtable/blocks';
 * ```
 * @docsPath models/Viewport
 */
declare class Viewport extends Watchable<WatchableViewportKey> {
    /**
     * Request to enter fullscreen mode.
     *
     * May fail if another block is fullscreen or this block doesn't have
     * permission to fullscreen itself. Watch `isFullscreen` to know if the
     * request succeeded.
     */
    enterFullscreenIfPossible(): void;
    /** Request to exit fullscreen mode */
    exitFullscreen(): void;
    /**
     * The maximum dimensions of the block when it is in
     * fullscreen mode. Returns the smallest set of dimensions added with
     * {@link addMaxFullscreenSize}.
     *
     * If `width` or `height` is null, it means there is
     * no max size constraint on that dimension. If `maxFullscreenSize` would be
     * smaller than {@link minSize}, it is constrained to be at least `minSize`.
     */
    get maxFullscreenSize(): ViewportSizeConstraint;
    /**
     * Add a maximum fullscreen size constraint. Use `.maxFullscreenSize` to get
     * the aggregate of all added constraints.
     *
     * Returns a function that can be called to remove the fullscreen size constraint that was added.
     *
     * @param sizeConstraint The width and height constraints to add. Both
     * `width` and `height` are optional - if either is set to null, that means
     * there is no max size in that dimension.
     */
    addMaxFullscreenSize(sizeConstraint: Partial<ViewportSizeConstraint>): UnsetFn;
    /**
     * The minimum dimensions of the block - if the viewport gets smaller than this
     * size, an overlay will be shown asking the user to resize the block to be bigger.
     *
     * The largest set of dimensions added with addMinSize. If `width` or `height` is null, it means
     * there is no minSize constraint on that dimension.
     */
    get minSize(): ViewportSizeConstraint;
    /**
     * Add a minimum frame size constraint. Use `.minSize`` to get the aggregate
     * of all added constraints.
     *
     * Upon adding a constraint, if the block is focused and the frame is smaller than the
     * minimum size, the block will enter fullscreen mode.
     *
     * Returns a function that can be called to remove the  size constraint that was added.
     *
     * @param sizeConstraint The width and height constraints to add. Both `width`
     * and `height` are optional - if either is set to null, that means there is
     * no min size in that dimension.
     */
    addMinSize(sizeConstraint: Partial<ViewportSizeConstraint>): UnsetFn;
    /**
     * `true` if the block frame is smaller than `minSize`, `false` otherwise.
     */
    get isSmallerThanMinSize(): boolean;
    /**
     * `true` if the block is fullscreen, `false` otherwise.
     */
    get isFullscreen(): boolean;
    /**
     * The current size of the block frame.
     *
     * Can be watched.
     */
    get size(): {
        width: number;
        height: number;
    };
    /**
     * Get notified of changes to the viewport.
     *
     * Watchable keys are:
     * - `'isFullscreen'`
     * - `'size'`
     * - `'minSize'`
     * - `'maxFullscreenSize'`
     *
     * Every call to `.watch` should have a matching call to `.unwatch`.
     *
     * Returns the array of keys that were watched.
     *
     * @param keys the keys to watch
     * @param callback a function to call when those keys change
     * @param context an optional context for `this` in `callback`.
     */
    watch(keys: WatchableViewportKey | ReadonlyArray<WatchableViewportKey>, callback: FlowAnyFunction, context?: FlowAnyObject | null): Array<WatchableViewportKey>;
    /**
     * Unwatch keys watched with `.watch`.
     *
     * Should be called with the same arguments given to `.watch`.
     *
     * Returns the array of keys that were unwatched
     *
     * @param keys the keys to unwatch
     * @param callback the function passed to `.watch` for these keys
     * @param context the context that was passed to `.watch` for this `callback`
     */
    unwatch(keys: WatchableViewportKey | ReadonlyArray<WatchableViewportKey>, callback: FlowAnyFunction, context?: FlowAnyObject | null): Array<WatchableViewportKey>;
}
export default Viewport;
//# sourceMappingURL=viewport.d.ts.map