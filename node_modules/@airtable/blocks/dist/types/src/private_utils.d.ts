import * as React from 'react';
import PropTypes from 'prop-types';
export { default as isDeepEqual } from 'fast-deep-equal';
/** @hidden */
export declare type FlowAnyObject = any;
/** @hidden */
export declare type FlowAnyFunction = any;
/** @hidden */
export declare type FlowAnyExistential = any;
/**
 * Get the type of all the values of an object.
 *
 * Same as the legacy Flow `$Values<T>` type.
 *
 * @hidden
 */
export declare type ObjectValues<T extends object> = T[keyof T];
/** @hidden */
export declare type TimeoutId = ReturnType<typeof setTimeout>;
/**
 * Extract the type of `ref` from a react component
 *
 * @hidden
 */
export declare type ReactRefType<C> = C extends React.Component ? C : C extends new (props: any) => React.Component ? C : C extends React.RefForwardingComponent<infer T, any> ? T : (C extends React.JSXElementConstructor<{
    ref?: infer R;
}> ? R : C extends keyof JSX.IntrinsicElements ? JSX.IntrinsicElements[C]['ref'] : unknown) extends React.Ref<infer T> | string | undefined ? T : unknown;
/**
 * Allows creating an object map type with a dynamic key type.
 *
 * TypeScript only allows `string` for `K` in `{[key: K]: V}` so we need a utility to bridge
 * the gap.
 *
 * This is an alias for TypeScript’s `Record` type, but the name “record” is confusing given our
 * Airtable domain model.
 *
 * @hidden
 */
export declare type ObjectMap<K extends PropertyKey, V> = {
    [P in K]: V;
};
/**
 * Creates an enum from provided string arguments.
 *
 * Useful for consumer-facing enums (eg `Button#variant`) where we want to make the external
 * developer experience convenient by providing a string value, but also want to internally
 * reference enum values using object notation.
 *
 * @hidden
 */
export declare function createEnum<T extends string>(...enumValues: Array<T>): {
    [K in T]: K;
};
/**
 * Creates a React propType for a provided enum.
 *
 * @hidden
 */
export declare function createPropTypeFromEnum<T extends string>(enumData: {
    [K in T]: T;
}): PropTypes.Requireable<T>;
/**
 * Creates a responsive React propType for a provided enum.
 *
 * This allows the prop to be either a valid enum property, or a map of viewport sizes to valid enum
 * properties.
 *
 * @hidden
 */
export declare function createResponsivePropTypeFromEnum<T extends string>(enumData: {
    [K in T]: T;
}): PropTypes.Validator<any>;
/**
 * Creates a Type for an enum created using `createEnum`.
 *
 * @hidden
 */
export declare type EnumType<T> = keyof T;
/**
 * Safely cast a value to the type passed in as a type parameter.
 *
 * This was added in the TypeScript migration to provide a safe translation for Flow’s type cast
 * operator `(x: T)`.
 *
 * @hidden
 */
export declare function cast<T>(x: T): T;
/**
 * @hidden
 */
export declare function cloneDeep<T extends unknown>(obj: T): T;
/**
 * @hidden
 */
export declare function keys<Obj extends object>(obj: Obj): Array<keyof Obj>;
/**
 * @hidden
 */
export declare function values<Obj extends object>(obj: Obj): Array<ObjectValues<Obj>>;
/**
 * @hidden
 */
export declare function entries<Obj extends object>(obj: Obj): Array<[keyof Obj, ObjectValues<Obj>]>;
/**
 * @hidden
 */
export declare function fireAndForgetPromise(fn: () => Promise<unknown>): void;
/**
 * @hidden
 */
export declare function has<T extends object>(obj: T, key: PropertyKey): key is keyof T;
/**
 * @hidden
 */
export declare function getEnumValueIfExists<K extends string, V extends string>(enumObj: ObjectMap<K, V>, valueToCheck: string): V | null;
/**
 * @hidden
 */
export declare function assertEnumValue<K extends string, V extends string>(enumObj: ObjectMap<K, V>, valueToCheck: string): V;
/**
 * @hidden
 */
export declare function isEnumValue(enumObj: {
    [key: string]: string;
}, valueToCheck: string): boolean;
/**
 * @hidden
 */
export declare function isObjectEmpty(obj: object): boolean;
/**
 * @hidden
 */
export declare function isNullOrUndefinedOrEmpty(value: unknown): boolean;
/**
 * @hidden
 */
export declare function compact<T>(array: ReadonlyArray<T | null | undefined>): Array<T>;
/**
 * @hidden
 */
export declare function clamp(n: number, lowerBound: number, upperBound: number): number;
/** @hidden */
interface ReadonlyDeepArray<T> extends Array<T | ReadonlyDeepArray<T>> {
}
/**
 * @hidden
 */
export declare function flattenDeep<T>(array: ReadonlyDeepArray<T>): Array<T>;
/**
 * @hidden
 */
export declare function keyBy<Item, Key extends string>(array: ReadonlyArray<Item>, getKey: (arg1: Item) => Key): ObjectMap<Key, Item>;
/**
 * @hidden
 */
export declare function uniqBy<Item, Key>(array: ReadonlyArray<Item>, getKey: (arg1: Item) => Key): Array<Item>;
/** @hidden */
export declare function getLocallyUniqueId(prefix?: string): string;
/**
 * A more restrictive version of Lodash's `get`. Notable differences:
 * - Will only search an object's own properties
 * - Only allows indexing into plain objects - searching in `number`, `string`, `Array`, `null`, or non-plain objects will throw
 *
 * @hidden
 */
export declare function getValueAtOwnPath(value: unknown, path: ReadonlyArray<string>): unknown;
/** @hidden */
export declare function arrayDifference<T>(a: ReadonlyArray<T>, b: ReadonlyArray<T>): Array<T>;
/** @hidden */
export declare function debounce<Args extends Array<any>>(fn: (...args: Args) => void, timeoutMs: number): (...args: Args) => void;
//# sourceMappingURL=private_utils.d.ts.map